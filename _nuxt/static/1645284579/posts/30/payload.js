__NUXT_JSONP__("/posts/30", {data:[{}],fetch:{"0":{zoom:null,pageCount:true,title:"Rust 新手错误和最差实践",author:"Yidadaa",date:"2021\u002F12\u002F26",content:"\u003Cblockquote\u003E\n\u003Cp\u003E原文：\u003Ca href=\"https:\u002F\u002Fadventures.michaelfbryan.com\u002Fposts\u002Frust-best-practices\u002Fbad-habits\u002F#using-sentinel-values\"\u003ECommon Newbie Mistakes and Bad Practices in Rust: Bad Habits\u003C\u002Fa\u003E\u003Cbr\u003E\n译者：\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FYidadaa\"\u003EYidadaa\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E很多从其他语言过来的 Rust 新手都会不可避免地利用之前的编码经验来写 Rust，这无可厚非，毕竟确实没必要从头开始学习编程知识。但是，这些经验性知识，却极有可能导致你写出来很垃圾的 Rust 代码。\u003C\u002Fp\u003E\n\u003Ch2\u003E别再用哨兵值了\u003C\u002Fh2\u003E\n\u003Cp\u003E这可能是我最讨厌的一点。在大多数沿袭 C 语言设计的语言中（C，C#，Java 等），经常使用一个特殊值来表示某个函数执行失败的情况。比如，在 C# 中，用于在字符串中查找另一个字符串的索引位置的函数 \u003Ccode\u003EString.IndexOf(t)\u003C\u002Fcode\u003E 会在找不到 \u003Ccode\u003Et\u003C\u002Fcode\u003E 时返回 \u003Ccode\u003E-1\u003C\u002Fcode\u003E，从而写出这样的 C# 代码：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-built_in\"\u003Estring\u003C\u002Fspan\u003E sentence = \u003Cspan class=\"hljs-string\"\u003E&quot;The fox jumps over the dog&quot;\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E index = sentence.IndexOf(\u003Cspan class=\"hljs-string\"\u003E&quot;fox&quot;\u003C\u002Fspan\u003E);\n\n\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (index != \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E)\n{\n  \u003Cspan class=\"hljs-built_in\"\u003Estring\u003C\u002Fspan\u003E wordsAfterFox = sentence.SubString(index);\n  Console.WriteLine(wordsAfterFox);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在其他的语言中，这种用法更是数不胜数，类似的哨兵值还有空字符串 \u003Ccode\u003E&quot;&quot;\u003C\u002Fcode\u003E 或者 \u003Ccode\u003Enull\u003C\u002Fcode\u003E、\u003Ccode\u003ENone\u003C\u002Fcode\u003E 之类的空值。\u003C\u002Fp\u003E\n\u003Cp\u003E既然它这么常用，为什么还要说它很差劲呢？原因就是你极有可能会忘记处理哨兵值所代表的失败情况，然后导致整个程序直接崩溃。\u003C\u002Fp\u003E\n\u003Cp\u003ERust 则提供了很好的解决方案，那就是 \u003Ccode\u003EOption\u003C\u002Fcode\u003E。\u003Ccode\u003EOption\u003C\u002Fcode\u003E 从设计层面就杜绝了忘记考虑 \u003Ccode\u003ENone\u003C\u002Fcode\u003E 时的情况，编译器会在编译时就进行强制检查，如果你忘了处理 \u003Ccode\u003ENone\u003C\u002Fcode\u003E，编译器会马上告诉你。上面字符串例子的代码，在 Rust 中可以写成这样：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E sentence = \u003Cspan class=\"hljs-string\"\u003E&quot;The fox jumps over the dog&quot;\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E index = sentence.find(\u003Cspan class=\"hljs-string\"\u003E&quot;fox&quot;\u003C\u002Fspan\u003E);\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F let words_after_fox = &amp;sentence[index..];\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果你直接使用 index，会得到报错：Error: Can&#x27;t index str with Option&lt;usize&gt;\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(fox) = index {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E words_after_fox = &amp;sentence[fox..];\n  \u003Cspan class=\"hljs-built_in\"\u003Eprintln!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;{}&quot;\u003C\u002Fspan\u003E, words_after_fox);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003E别再用匈牙利命名了\u003C\u002Fh2\u003E\n\u003Cp\u003E上世纪 70 年代，程序员们逐渐开始在无类型或动态类型语言中使用\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FHungarian_notation\"\u003E匈牙利命名法\u003C\u002Fa\u003E，他们给变量名加上不同的前缀来表示变量的类型，比如 \u003Ccode\u003EbVisited\u003C\u002Fcode\u003E 表示布尔型的变量 \u003Ccode\u003Evisited\u003C\u002Fcode\u003E，\u003Ccode\u003EstrName\u003C\u002Fcode\u003E 表示字符串类型的变量 \u003Ccode\u003Ename\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E我们可以在 \u003Ccode\u003EDelphi\u003C\u002Fcode\u003E 语言中见到大量的例子，\u003Ccode\u003ET\u003C\u002Fcode\u003E 开头的表示类（class）或者类型（type），\u003Ccode\u003EF\u003C\u002Fcode\u003E 表示属性值（fields），\u003Ccode\u003EA\u003C\u002Fcode\u003E 表示参数（arguments），诸如此类。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E\n TKeyValue = \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eprivate\u003C\u002Fspan\u003E\n    FKey: integer;\n    FValue: TObject;\n  \u003Cspan class=\"hljs-keyword\"\u003Epublic\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eproperty\u003C\u002Fspan\u003E Key: integer \u003Cspan class=\"hljs-keyword\"\u003Eread\u003C\u002Fspan\u003E FKey \u003Cspan class=\"hljs-keyword\"\u003Ewrite\u003C\u002Fspan\u003E FKey;\n    \u003Cspan class=\"hljs-keyword\"\u003Eproperty\u003C\u002Fspan\u003E Value: TObject \u003Cspan class=\"hljs-keyword\"\u003Eread\u003C\u002Fspan\u003E FValue \u003Cspan class=\"hljs-keyword\"\u003Ewrite\u003C\u002Fspan\u003E FValue;\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EFrobnicate\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(ASomeArg: \u003Cspan class=\"hljs-keyword\"\u003Estring\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Estring\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-keyword\"\u003Eend\u003C\u002Fspan\u003E;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EC# 中也有类似的使用习惯，比如用 \u003Ccode\u003EI\u003C\u002Fcode\u003E 开头表示一个接口（interface），所以 C# 程序员很可能会写出这种 Rust 代码：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etrait\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EIClone\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eclone\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-keyword\"\u003ESelf\u003C\u002Fspan\u003E;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E你大可以直接扔掉前面的 \u003Ccode\u003EI\u003C\u002Fcode\u003E，因为 Rust 的语法已经保证了我们很难混淆 \u003Ccode\u003Etrait\u003C\u002Fcode\u003E 和 \u003Ccode\u003Etype\u003C\u002Fcode\u003E，不像 C# 很容易就分不清 \u003Ccode\u003Einterface\u003C\u002Fcode\u003E 和 \u003Ccode\u003Eclass\u003C\u002Fcode\u003E（译者按：Typescript 中就是 \u003Ccode\u003Einterface\u003C\u002Fcode\u003E、\u003Ccode\u003Etype\u003C\u002Fcode\u003E 和 \u003Ccode\u003Eclass\u003C\u002Fcode\u003E 大混战了，狗头.jpg）。\u003C\u002Fp\u003E\n\u003Cp\u003E此外，你也没有必要在给一些工具函数或者中间变量命名时带上它的类型信息，比如下面的代码：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E account_bytes: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Eu8\u003C\u002Fspan\u003E&gt; = read_some_input();\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E account_str = \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E::from_utf8(account_bytes)?;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E account: Account = account_str.parse()?;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E既然 \u003Ccode\u003EString.from_utf8()\u003C\u002Fcode\u003E 已经明明白白地返回了一个字符串，为什么还要在命名时加上 \u003Ccode\u003E_str\u003C\u002Fcode\u003E 后缀呢？\u003C\u002Fp\u003E\n\u003Cp\u003E与其他语言不同，Rust 语言鼓励程序员在对变量进行一系列变换操作时，使用同名变量覆写掉不再使用的旧值，比如：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E account: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Eu8\u003C\u002Fspan\u003E&gt; = read_some_input();\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E account = \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E::from_utf8(account)?;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E account: Account = account.parse()?;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E使用相同的变量名可以很好地保证概念的一致性。\u003C\u002Fp\u003E\n\u003Cp\u003E有些语言会明令禁止\u003Ca href=\"https:\u002F\u002Frules.sonarsource.com\u002Fcpp\u002FRSPEC-1117\"\u003E覆写变量\u003C\u002Fa\u003E，尤其像 Javascript 这种动态类型语言，因为频繁变化的类型，在缺少类型推断的情况下，尤其有可能会导致 bug 出现。\u003C\u002Fp\u003E\n\u003Ch2\u003E你可能不需要这么多 \u003Ccode\u003ERc&lt;RefCell&lt;T&gt;&gt;\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003EOOP 编程实践常常会保存其他对象的引用，并在合适的时候调用他们的函数，这没啥不好的，依赖注入（Dependency Injection）是个蛮不错的实践，不过有别于大多数面向对象的语言，Rust 并没有垃圾内存回收机制（Garbage Collector），并且对共享可变性非常敏感。\u003C\u002Fp\u003E\n\u003Cp\u003E举个例子，我们正要实现一个打怪兽的游戏，玩家需要对怪物们造成足量伤害才算打败他们（我也不知道为什么要这么设定，可能是接受了什么委托？）。\u003C\u002Fp\u003E\n\u003Cp\u003E先创建一个 \u003Ccode\u003EMonster\u003C\u002Fcode\u003E 类，包含 \u003Ccode\u003Ehealth\u003C\u002Fcode\u003E 生命值属性以及 \u003Ccode\u003EtakeDamage()\u003C\u002Fcode\u003E 遭受伤害的方法，为了能知道怪物遭受了多少伤害，我们允许为 \u003Ccode\u003EMonster\u003C\u002Fcode\u003E 类注入一个回调函数，该回调函数可以接收每次遭受的伤害值。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E OnReceivedDamage = \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003EdamageReceived: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Evoid\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EMonster\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-attr\"\u003Ehealth\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E50\u003C\u002Fspan\u003E;\n  receivedDamage: OnReceivedDamage[] = [];\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EtakeDamage\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eamount: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    amount = \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.min(\u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.health, amount);\n    \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.health -= amount;\n    \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.receivedDamage.forEach(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Ecb\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E cb(amount));\n  }\n\n  on(event: \u003Cspan class=\"hljs-string\"\u003E&quot;damaged&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-attr\"\u003Ecallback\u003C\u002Fspan\u003E: OnReceivedDamage): \u003Cspan class=\"hljs-built_in\"\u003Evoid\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.receivedDamage.push(callback);\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E然后设计一个伤害计数类 \u003Ccode\u003EDamageCounter\u003C\u002Fcode\u003E，可以累计怪物伤害值：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EDamageCounter\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-attr\"\u003EdamageInflicted\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n\n  reachedTargetDamage(): \u003Cspan class=\"hljs-built_in\"\u003Eboolean\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.damageInflicted &gt; \u003Cspan class=\"hljs-number\"\u003E100\u003C\u002Fspan\u003E;\n  }\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EonDamageInflicted\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eamount: \u003Cspan class=\"hljs-built_in\"\u003Enumber\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.damageInflicted += amount;\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E然后我们对怪物造成随机伤害，直到伤害计数达到上限。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E counter = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E DamageCounter();\n\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E monsters = [\n  \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Monster(),\n  \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Monster(),\n  \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Monster(),\n  \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Monster(),\n  \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Monster(),\n];\nmonsters.forEach(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Em\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E\n  m.on(\u003Cspan class=\"hljs-string\"\u003E&quot;damaged&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Eamount\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E counter.onDamageInflicted(amount))\n);\n\n\u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E (!counter.reachedTargetDamage()) {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 随机选中怪物\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E index = \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.floor(\u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.random() * monsters.length);\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E target = monsters[index];\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 产生随机伤害\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E damage = \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.round(\u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.random() * \u003Cspan class=\"hljs-number\"\u003E50\u003C\u002Fspan\u003E);\n  target.takeDamage(damage);\n\n  \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E`Monster \u003Cspan class=\"hljs-subst\"\u003E${index}\u003C\u002Fspan\u003E received \u003Cspan class=\"hljs-subst\"\u003E${damage}\u003C\u002Fspan\u003E damage`\u003C\u002Fspan\u003E);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里是\u003Ca href=\"https:\u002F\u002Fwww.typescriptlang.org\u002Fplay?#code\u002FC4TwDgpgBA8gdgJQgYwgSwG4QCYBECGAtvgObQC8UAFIQFxQCyA9nAM7AQBOANFNkaQhJUmHPTgBXQgCMuASijkAfFAxM02ANwAobcgA2+Vq0Yt2XKAG9tUW1AAWEfPuD3xU2Z0VQArAAYdOyhOFHQsPAEyenhhMJwCYjIAbQBdb1SdGztgfABrCATBKiImCThgdxl5Kyyg2xKy4G8GfFcAOkI0OCpXNFY2x2dXXgbyuUC6217+wZd7KABaSlHgTTrauum2kJFwwrI2gDMmTgBRfGR7KmRpRRUbnvs+kcJSsfGNgF9dIJYqCCw5XoACJ+IkcMDeMhnPppBdctFEKFRBFwXJ6GoNDVJlMnv0dnFUYI2mAJKwrtD9LD4R8gt9vnpDMYoPsIABhN4cLzWIJgwQASTgh30aGQHGwlU83gCPzsIQujmwABV8JwyMBWVR0VBpEwmPonHBsTiQsAJJwjVs+WRBcLReKoCoAIx+GV02W2Fis20isU4YqvRqS6o8nFWyIQH32nBQADUy0D5QmtnpumQZia6caFkocAgAHcWRGOdnOFrMum2E1XlWuCZKEk84XmLWy3JeE3TK2tR2C13zG3e82M1we1BOy2B1qUjoawP+sczgqaHcoIQ2n9QRHsJDqAB9F6chTKKBZ8pcDdwb1C33igNHuQfbT5p4G6gAQjPXO2TkuOBVaoQBqEZagooa2AA9BBUBgKKuRQPgwT4HA2BMIQa4jpwGyVuwUBdNgEAAB7NK09hHPoepli07ScMhqGEFqABUc5cv0BpwCQri0nYOFNDkgFNJQLF1kk+FETOGxQVArgQEa1rQGgTSIdIinYRmfARiRNFvNgVDUWRtEoWhWpQIxvh+NxUyquqbQ5PkmryU+QQ4fqEBtBRJBUAABpOXJQAAJJYYmEZ8wTIuEAWWPJoXydQwBMDk+gaeCeE3tGEqRV+F7yVGfrYJ8XkfJ8QA\"\u003E在线运行示例\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E然后我们用 Rust 重写上述逻辑，\u003Ccode\u003EMonster\u003C\u002Fcode\u003E 结构体结构保持不变，使用 \u003Ccode\u003EBox&lt;dyn Fn(u32)&gt;\u003C\u002Fcode\u003E 来接收闭包，该闭包接受一个 \u003Ccode\u003Eu32\u003C\u002Fcode\u003E 型参数。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EOnReceivedDamage\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-keyword\"\u003Edyn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EFn\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E)&gt;;\n\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EMonster\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n    health: \u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E,\n    received_damage: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;OnReceivedDamage&gt;,\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E Monster {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Etake_damage\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, amount: \u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E) {\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E damage_received = cmp::min(\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.health, amount);\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.health -= damage_received;\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E callback \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.received_damage {\n            callback(damage_received);\n        }\n    }\n\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eadd_listener\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, listener: OnReceivedDamage) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.received_damage.push(listener);\n    }\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EDefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E Monster {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Edefault\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() -&gt; \u003Cspan class=\"hljs-keyword\"\u003ESelf\u003C\u002Fspan\u003E {\n        Monster { health: \u003Cspan class=\"hljs-number\"\u003E100\u003C\u002Fspan\u003E, received_damage: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new() }\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E随后是 \u003Ccode\u003EDamageCounter\u003C\u002Fcode\u003E 类：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-meta\"\u003E#[derive(Default)]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EDamageCounter\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n    damage_inflicted: \u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E,\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E DamageCounter {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ereached_target_damage\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.damage_inflicted &gt; \u003Cspan class=\"hljs-number\"\u003E100\u003C\u002Fspan\u003E\n    }\n\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eon_damage_received\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, damage: \u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.damage_inflicted += damage;\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E然后开始打怪：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Emain\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E rng = rand::thread_rng();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E counter = DamageCounter::default();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E monsters: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;_&gt; = (\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E..\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E).map(|_| Monster::default()).collect();\n\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E monster \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E monsters {\n        monster.add_listener(\u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E::new(|damage| counter.on_damage_received(damage)));\n    }\n\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !counter.reached_target_damage() {\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E index = rng.gen_range(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E..monsters.len());\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E target = &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E monsters[index];\n\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E damage = rng.gen_range(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E..\u003Cspan class=\"hljs-number\"\u003E50\u003C\u002Fspan\u003E);\n        target.take_damage(damage);\n\n        \u003Cspan class=\"hljs-built_in\"\u003Eprintln!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;Monster {} received {} damage&quot;\u003C\u002Fspan\u003E, index, damage);\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E同样地，Rust 代码也有一个\u003Ca href=\"https:\u002F\u002Fplay.rust-lang.org\u002F?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a8cc547728ef102bbd5dc6b9cafb0ff6\"\u003E在线运行示例\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E然而，编译器狠狠地给我们报了四个错误，全都集中在 \u003Ccode\u003Emonster.add_listener()\u003C\u002Fcode\u003E 这一行：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Eerror[E0596]: cannot borrow `counter` \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E mutable, \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E it is a captured variable \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E a `\u003Cspan class=\"hljs-built_in\"\u003EFn\u003C\u002Fspan\u003E` closure\n  --&gt; src\u002Fmain.rs:\u003Cspan class=\"hljs-number\"\u003E47\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-number\"\u003E48\u003C\u002Fspan\u003E\n   |\n\u003Cspan class=\"hljs-number\"\u003E47\u003C\u002Fspan\u003E |         monster.add_listener(\u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E::new(|damage| counter.on_damage_received(damage)));\n   |                                                ^^^^^^^ cannot borrow \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E mutable\n\nerror[E0499]: cannot borrow `counter` \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E mutable more than once at a time\n  --&gt; src\u002Fmain.rs:\u003Cspan class=\"hljs-number\"\u003E47\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-number\"\u003E39\u003C\u002Fspan\u003E\n   |\n\u003Cspan class=\"hljs-number\"\u003E47\u003C\u002Fspan\u003E |         monster.add_listener(\u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E::new(|damage| counter.on_damage_received(damage)));\n   |                              ---------^^^^^^^^------------------------------------\n   |                              |        |        |\n   |                              |        |        borrows occur due to \u003Cspan class=\"hljs-keyword\"\u003Euse\u003C\u002Fspan\u003E of `counter` \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E closure\n   |                              |        `counter` was mutably borrowed here \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E the previous iteration of the \u003Cspan class=\"hljs-keyword\"\u003Eloop\u003C\u002Fspan\u003E\n   |                              cast requires that `counter` is borrowed \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E `\u003Cspan class=\"hljs-symbol\"\u003E&#x27;static\u003C\u002Fspan\u003E`\n\nerror[E0597]: `counter` does not live long enough\n  --&gt; src\u002Fmain.rs:\u003Cspan class=\"hljs-number\"\u003E47\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-number\"\u003E48\u003C\u002Fspan\u003E\n   |\n\u003Cspan class=\"hljs-number\"\u003E47\u003C\u002Fspan\u003E |         monster.add_listener(\u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E::new(|damage| counter.on_damage_received(damage)));\n   |                              ------------------^^^^^^^----------------------------\n   |                              |        |        |\n   |                              |        |        borrowed value does not live long enough\n   |                              |        value captured here\n   |                              cast requires that `counter` is borrowed \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E `\u003Cspan class=\"hljs-symbol\"\u003E&#x27;static\u003C\u002Fspan\u003E`\n...\n\u003Cspan class=\"hljs-number\"\u003E60\u003C\u002Fspan\u003E | }\n   | - `counter` dropped here \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E still borrowed\n\nerror[E0502]: cannot borrow `counter` \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E immutable because it is also borrowed \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E mutable\n  --&gt; src\u002Fmain.rs:\u003Cspan class=\"hljs-number\"\u003E50\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-number\"\u003E12\u003C\u002Fspan\u003E\n   |\n\u003Cspan class=\"hljs-number\"\u003E47\u003C\u002Fspan\u003E |         monster.add_listener(\u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E::new(|damage| counter.on_damage_received(damage)));\n   |                              -----------------------------------------------------\n   |                              |        |        |\n   |                              |        |        first borrow occurs due to \u003Cspan class=\"hljs-keyword\"\u003Euse\u003C\u002Fspan\u003E of `counter` \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E closure\n   |                              |        mutable borrow occurs here\n   |                              cast requires that `counter` is borrowed \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E `\u003Cspan class=\"hljs-symbol\"\u003E&#x27;static\u003C\u002Fspan\u003E`\n...\n\u003Cspan class=\"hljs-number\"\u003E50\u003C\u002Fspan\u003E |     \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !counter.reached_target_damage() {\n   |            ^^^^^^^ immutable borrow occurs here\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E看起来是一团乱麻，让我来翻译翻译&lt;del&gt;，什么叫惊喜&lt;\u002Fdel&gt;：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E闭包捕获了对 \u003Ccode\u003Ecounter\u003C\u002Fcode\u003E 的引用；\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Ecounter.on_damage_received()\u003C\u002Fcode\u003E 方法接受 \u003Ccode\u003E&amp;mut self\u003C\u002Fcode\u003E，所以闭包需要 \u003Ccode\u003E&amp;mut\u003C\u002Fcode\u003E 可变引用。由于这个闭包在循环里，所以对同一个对象的可变引用 \u003Ccode\u003E&amp;mut\u003C\u002Fcode\u003E 会执行多次，这是不被 Rust 允许的；\u003C\u002Fli\u003E\n\u003Cli\u003E我们传入的闭包没有任何生命周期标记，意味着它需要掌控所有包含变量的所有权，所以 \u003Ccode\u003Ecounter\u003C\u002Fcode\u003E 需要被移动到闭包内部，而在循环中，重复移动某值就会造成 \u003Ccode\u003Euse of moved value\u003C\u002Fcode\u003E 错误；\u003C\u002Fli\u003E\n\u003Cli\u003E当 \u003Ccode\u003Ecounter\u003C\u002Fcode\u003E 被移动到闭包内后，我们又尝试在条件语句中使用它，显然也会报错。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E总之，情况不太妙。\u003C\u002Fp\u003E\n\u003Cp\u003E一个经典解决方法是把 \u003Ccode\u003EDamageCounter\u003C\u002Fcode\u003E 用引用计数指针裹起来，这样我们可以重复使用它了，此外由于我们需要使用 \u003Ccode\u003E&amp;mut self\u003C\u002Fcode\u003E，所以我们需要使用 \u003Ccode\u003ERefCell\u003C\u002Fcode\u003E 来在运行时做借用检查（borrow checking），而不是在编译时。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E fn main() {\n     let mut rng = rand::thread_rng();\n\u003Cspan class=\"hljs-deletion\"\u003E-    let mut counter = DamageCounter::default();\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+    let mut counter = Rc::new(RefCell::new(DamageCounter::default()));\u003C\u002Fspan\u003E\n     let mut monsters: Vec&lt;_&gt; = (0..5).map(|_| Monster::default()).collect();\n\n     for monster in &amp;mut monsters {\n\u003Cspan class=\"hljs-deletion\"\u003E-        monster.add_listener(Box::new(|damage| counter.on_damage_received(damage)));\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+        let counter = Rc::clone(&amp;counter);\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+        monster.add_listener(Box::new(move |damage| {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+            counter.borrow_mut().on_damage_received(damage)\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+        }));\u003C\u002Fspan\u003E\n     }\n\n\u003Cspan class=\"hljs-deletion\"\u003E-    while !counter.reached_target_damage() {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+    while !counter.borrow().reached_target_damage() {\u003C\u002Fspan\u003E\n         let index = rng.gen_range(0..monsters.len());\n         let target = &amp;mut monsters[index];\n         ...\n     }\n }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里是\u003Ca href=\"https:\u002F\u002Fplay.rust-lang.org\u002F?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7aca92432f337fa29de62999ea5709b8\"\u003E改动后的代码\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E虽然现在代码可以正常运行了，但是整块代码会被 \u003Ccode\u003ERc&lt;RefCell&gt;Vec&lt;Foo&gt;&gt;&gt;\u003C\u002Fcode\u003E 之类的玩意儿搞得乌烟瘴气。而且当代码变得更复杂时，\u003Ccode\u003ERefCell\u003C\u002Fcode\u003E 也有可能会被可变借用多次。而如果在多线程中使用了 \u003Ccode\u003EArc&lt;Mutex&lt;Vec&lt;Foo&gt;&gt;&gt;\u003C\u002Fcode\u003E，\u003Ccode\u003ERefCell\u003C\u002Fcode\u003E 引发 panic 之后，整个程序会死锁。\u003C\u002Fp\u003E\n\u003Cp\u003E所以，一个更好的解决方法是避免在结构体中存储持久化引用。我们对 \u003Ccode\u003EMonster::take_damage()\u003C\u002Fcode\u003E 稍加改造：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EMonster\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n    health: \u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E,\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E Monster {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Etake_damage\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, amount: \u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E, on_damage_received: \u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EFnOnce\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E)) {\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E damage_received = cmp::min(\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.health, amount);\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.health -= damage_received;\n        on_damage_received(damage_received);\n    }\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EDefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E Monster {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Edefault\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() -&gt; \u003Cspan class=\"hljs-keyword\"\u003ESelf\u003C\u002Fspan\u003E { Monster { health: \u003Cspan class=\"hljs-number\"\u003E100\u003C\u002Fspan\u003E } }\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 省略了 `DamageCounter` 的代码\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Emain\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E rng = rand::thread_rng();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E counter = DamageCounter::default();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E monsters: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;_&gt; = (\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E..\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E).map(|_| Monster::default()).collect();\n\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !counter.reached_target_damage() {\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E index = rng.gen_range(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E..monsters.len());\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E target = &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E monsters[index];\n\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E damage = rng.gen_range(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E..\u003Cspan class=\"hljs-number\"\u003E50\u003C\u002Fspan\u003E);\n        target.take_damage(damage, |dmg| counter.on_damage_received(dmg));\n\n        \u003Cspan class=\"hljs-built_in\"\u003Eprintln!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;Monster {} received {} damage&quot;\u003C\u002Fspan\u003E, index, damage);\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里是\u003Ca href=\"https:\u002F\u002Fplay.rust-lang.org\u002F?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=52b789a7616efe6c2e24b7e1949f7c03\"\u003E在线示例\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E由于避免了存储回调函数，改造后的代码行数从 62 行下降到了 47 行。\u003C\u002Fp\u003E\n\u003Cp\u003E此外，我们也可以给 \u003Ccode\u003Etake_damage()\u003C\u002Fcode\u003E 加个返回值，这样可以把伤害值放在返回值里，以备后用：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E Monster {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Etake_damage\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, amount: \u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E) -&gt; AttackSummary {\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E damage_received = cmp::min(\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.health, amount);\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.health -= damage_received;\n        AttackSummary { damage_received }\n    }\n}\n\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EAttackSummary\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n    damage_received: \u003Cspan class=\"hljs-built_in\"\u003Eu32\u003C\u002Fspan\u003E,\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 省略了 `DamageCounter` 的代码\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Emain\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E rng = rand::thread_rng();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E counter = DamageCounter::default();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E monsters: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;_&gt; = (\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E..\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E).map(|_| Monster::default()).collect();\n\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !counter.reached_target_damage() {\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E index = rng.gen_range(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E..monsters.len());\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E target = &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E monsters[index];\n\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E damage = rng.gen_range(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E..\u003Cspan class=\"hljs-number\"\u003E50\u003C\u002Fspan\u003E);\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E AttackSummary { damage_received } = target.take_damage(damage);\n        counter.on_damage_received(damage_received);\n\n        \u003Cspan class=\"hljs-built_in\"\u003Eprintln!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;Monster {} received {} damage&quot;\u003C\u002Fspan\u003E, index, damage);\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E当代码复杂度上升时，代码也不会变成一团糟，而且它看起来更“函数式”。\u003C\u002Fp\u003E\n\u003Ch2\u003E错用整数类型\u003C\u002Fh2\u003E\n\u003Cp\u003E另一个从 C 语言带来的坏毛病是错用整数类型，导致代码里到处都是 \u003Ccode\u003Eusize\u003C\u002Fcode\u003E 的类型转换，尤其是在对数组做索引时。\u003C\u002Fp\u003E\n\u003Cp\u003EC 程序员在初学时就被各种教程教会了使用 \u003Ccode\u003Eint\u003C\u002Fcode\u003E 类型来做索引和循环，当他们开始写 Rust 时，也自然而然地用 \u003Ccode\u003EVec&lt;i32&gt;\u003C\u002Fcode\u003E 类型来做数组切片。但是阿 Rust 真的很严格，不让程序员使用 \u003Ccode\u003Eusize\u003C\u002Fcode\u003E 以外的类型对数组、切片和 \u003Ccode\u003EVec\u003C\u002Fcode\u003E 进行索引，这就不得不在索引的时候进行一次 \u003Ccode\u003Ei32 as usize\u003C\u002Fcode\u003E 的类型转换。\u003C\u002Fp\u003E\n\u003Cp\u003ERust 这么做有诸多好处：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E无符号类型可以避免负数索引（译者按：Python 程序员请求出战）；\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eusize\u003C\u002Fcode\u003E 与普通指针的大小相同，指针运算不会造成隐式类型转换；\u003C\u002Fli\u003E\n\u003Cli\u003E内存操作函数 \u003Ccode\u003Estd::mem::size_of()\u003C\u002Fcode\u003E 和 \u003Ccode\u003Estd::mem::align_of()\u003C\u002Fcode\u003E 返回 \u003Ccode\u003Eusize\u003C\u002Fcode\u003E 类型。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E所以，请尽量使用 \u003Ccode\u003Eusize\u003C\u002Fcode\u003E 类型作为可能涉及索引操作的中间变量的首选类型。\u003C\u002Fp\u003E\n\u003Ch2\u003E没人比我更懂 \u003Ccode\u003Eunsafe\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E每次当我看到 C 程序员使用 \u003Ccode\u003Estd::mem::transmute()\u003C\u002Fcode\u003E 函数或者裸指针来跳过编译器的借用检查时，我都会想起论坛中那条古老的 Rust 圣经：\u003Ca href=\"https:\u002F\u002Fusers.rust-lang.org\u002Ft\u002Frust-koans\u002F2408?u=michael-f-bryan\"\u003EObstacles, by Daniel Keep\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E建议你现在就去读一读，我可以等。（译者按：有空了给大伙翻译一下。）\u003C\u002Fp\u003E\n\u003Cp\u003E你可能已经身经百战见得多了，精通八种编程语言，所以毫无顾忌地破坏 Rust 精心构筑的规则：创建自引用的结构体、用 \u003Ccode\u003Eunsafe\u003C\u002Fcode\u003E 创建全局变量。而且每一次，你都用同样的借口：“这是个单线程程序，所以 \u003Ccode\u003Estatic mut\u003C\u002Fcode\u003E 百分之一万没问题”、“这在 C 语言里跑得好好的”。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Eunsafe\u003C\u002Fcode\u003E 很微妙，你必须要对 Rust 的借用检查规则和内存模型有深刻的认识才行。我也不想像祥林嫂一样念叨：“未成年人请在编译器监督下编写 \u003Ccode\u003Eunsafe\u003C\u002Fcode\u003E 多线程代码”，但如果你刚开始学这门语言，我衷心建议你耐心从编译器报错的痛苦中慢慢品味 Rust 的美妙。\u003C\u002Fp\u003E\n\u003Cp\u003E当你成为了 Rust 大师，你可以尽情玩弄 \u003Ccode\u003Eunsafe\u003C\u002Fcode\u003E 代码，但在那之前，我还是想告诉你，\u003Ccode\u003Eunsafe\u003C\u002Fcode\u003E 不是杀死编译器报错的板蓝根，也不是能让你自在书写 C 风味 Rust 代码的作弊码。\u003C\u002Fp\u003E\n\u003Ch2\u003E不舍得用命名空间\u003C\u002Fh2\u003E\n\u003Cp\u003EC 语言中的另一个常见实践是给函数增加所属的库名或者模块名作为前缀，比如 \u003Ccode\u003Erune_wasmer_runtime_load()\u003C\u002Fcode\u003E 就表示 \u003Ccode\u003Erune\u003C\u002Fcode\u003E 库的 \u003Ccode\u003Ewasmer\u002Fruntime\u003C\u002Fcode\u003E 模块下的 \u003Ccode\u003Eload()\u003C\u002Fcode\u003E 函数。Rust 提供了非常好用的命名空间机制，请尽情使用它，比如刚刚这个函数就可以写成 \u003Ccode\u003Erune::wasmer::Runtime::load()\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Ch2\u003E滥用切片索引\u003C\u002Fh2\u003E\n\u003Cp\u003EC 语言离不开 \u003Ccode\u003Efor (int i = 0; i &lt; n; i ++)\u003C\u002Fcode\u003E，就像西方不能没有耶路撒冷。\u003C\u002Fp\u003E\n\u003Cp\u003E所以下面的 Rust 的代码也就不足为奇：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E points: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Coordinate&gt; = ...;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E differences = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n\n\u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E i \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..points.len() [\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E current = points[i];\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E previous = points[i-\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E];\n  differences.push(current - previous);\n]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E就像呼吸一样自然。然而，就算是老司机也难免会中招下标越界 bug ，尤其当你想在循环里取前一个值时，你就得花心思去考虑 \u003Ccode\u003Ei\u003C\u002Fcode\u003E 是否是从 1 开始的。\u003C\u002Fp\u003E\n\u003Cp\u003ERust 很担心你，所以拿出了迭代器，切片类型甚至还有 \u003Ccode\u003Ewindows()\u003C\u002Fcode\u003E 和 \u003Ccode\u003Earray_windows()\u003C\u002Fcode\u003E 这种高级函数来获取相邻的元素对。上面的代码可以重写为：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E points: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Coordinate&gt; = ...;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E differences = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n\n\u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E [previous, current] \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E points.array_windows().copied() {\n  differences.push(current - previous);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E甚至可以用链式调用来炫技：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E differences: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;_&gt; = points\n  .array_windows()\n  .copied()\n  .map(|[previous, current]| current - previous)\n  .collect();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E有些人会主张使用了 \u003Ccode\u003Emap()\u003C\u002Fcode\u003E 和 \u003Ccode\u003Ecollect\u003C\u002Fcode\u003E 版本的代码更加“函数式“，我则觉得仁者见仁，智者见智。\u003C\u002Fp\u003E\n\u003Cp\u003E不仅如此，迭代器的性能往往比朴素的 \u003Ccode\u003Efor\u003C\u002Fcode\u003E 循环更好，你可以在\u003Ca href=\"https:\u002F\u002Fusers.rust-lang.org\u002Ft\u002Fwe-all-know-iter-is-faster-than-loop-but-why\u002F51486\u002F7?u=michael-f-bryan\"\u003E这里\u003C\u002Fa\u003E了解原因。\u003C\u002Fp\u003E\n\u003Ch2\u003E滥用迭代器\u003C\u002Fh2\u003E\n\u003Cp\u003E一旦你用迭代器用上瘾了，你极有可能跑向对立面：拿着迭代器这个锤子，看啥都像钉子。由 \u003Ccode\u003Emap\u003C\u002Fcode\u003E，\u003Ccode\u003Efilter\u003C\u002Fcode\u003E 和 \u003Ccode\u003Eand_then()\u003C\u002Fcode\u003E 堆叠成的链式调用会让代码可读性下降，而且频繁使用闭包，会让数据类型变得不再直观。\u003C\u002Fp\u003E\n\u003Cp\u003E下面有个例子，演示了迭代器如何让你的代码变得更复杂，你可以读一读这段代码，并猜猜它是干啥的：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Efunctional_blur\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(input: &amp;Matrix) -&gt; Matrix {\n    \u003Cspan class=\"hljs-built_in\"\u003Eassert!\u003C\u002Fspan\u003E(input.width &gt;= \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-built_in\"\u003Eassert!\u003C\u002Fspan\u003E(input.height &gt;= \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E);\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 先保存首尾两行，方便后续使用\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E rows = input.rows();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E first_row = rows.next().unwrap();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E last_row = rows.next_back().unwrap();\n\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E top_row = input.rows();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E middle_row = input.rows().skip(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E bottom_row = input.rows().skip(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E);\n\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E blurred_elements = top_row\n        .zip(middle_row)\n        .zip(bottom_row)\n        .flat_map(|((top, middle), bottom)| blur_rows(top, middle, bottom));\n\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E elements: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Ef32\u003C\u002Fspan\u003E&gt; = first_row\n        .iter()\n        .copied()\n        .chain(blurred_elements)\n        .chain(last_row.iter().copied())\n        .collect();\n\n    Matrix::new_row_major(elements, input.width, input.height)\n}\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eblur_rows\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E&gt;(\n    top_row: &amp;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E [\u003Cspan class=\"hljs-built_in\"\u003Ef32\u003C\u002Fspan\u003E],\n    middle_row: &amp;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E [\u003Cspan class=\"hljs-built_in\"\u003Ef32\u003C\u002Fspan\u003E],\n    bottom_row: &amp;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E [\u003Cspan class=\"hljs-built_in\"\u003Ef32\u003C\u002Fspan\u003E],\n) -&gt; \u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EIterator\u003C\u002Fspan\u003E&lt;Item = \u003Cspan class=\"hljs-built_in\"\u003Ef32\u003C\u002Fspan\u003E&gt; + \u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 保存头尾元素，以备后用\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E &amp;first = middle_row.first().unwrap();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E &amp;last = middle_row.last().unwrap();\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 获取上中下的 3x3 矩阵来做平均\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E top_window = top_row.windows(\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E middle_window = middle_row.windows(\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E bottom_window = bottom_row.windows(\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E);\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 滑动窗口取均值，除了首尾元素\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E averages = top_window\n        .zip(middle_window)\n        .zip(bottom_window)\n        .map(|((top, middle), bottom)| top.iter().chain(middle).chain(bottom).sum::&lt;\u003Cspan class=\"hljs-built_in\"\u003Ef32\u003C\u002Fspan\u003E&gt;() \u002F \u003Cspan class=\"hljs-number\"\u003E9.0\u003C\u002Fspan\u003E);\n\n    std::iter::once(first)\n        .chain(averages)\n        .chain(std::iter::once(last))\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.rust-lang.org\u002F?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=da8fa6e55ca5a0de6005b13672688c14\"\u003E在线示例\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E看起来好像并不难，做个均值滤波罢了，不过我这里有个更好的实现：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eimperative_blur\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(input: &amp;Matrix) -&gt; Matrix {\n    \u003Cspan class=\"hljs-built_in\"\u003Eassert!\u003C\u002Fspan\u003E(input.width &gt;= \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-built_in\"\u003Eassert!\u003C\u002Fspan\u003E(input.height &gt;= \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E);\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 直接从输入值拷贝返回值矩阵，这样就不需要考虑边界条件\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E output = input.clone();\n\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E y \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..(input.height - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E x \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..(input.width - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E pixel_value = \u003Cspan class=\"hljs-number\"\u003E0.0\u003C\u002Fspan\u003E;\n\n            pixel_value += input[[x - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, y - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E]];\n            pixel_value += input[[x, y - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E]];\n            pixel_value += input[[x + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, y - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E]];\n\n            pixel_value += input[[x - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, y]];\n            pixel_value += input[[x, y]];\n            pixel_value += input[[x + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, y]];\n\n            pixel_value += input[[x - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, y + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E]];\n            pixel_value += input[[x, y + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E]];\n            pixel_value += input[[x + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, y + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E]];\n\n            output[[x, y]] = pixel_value \u002F \u003Cspan class=\"hljs-number\"\u003E9.0\u003C\u002Fspan\u003E;\n        }\n    }\n\n    output\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fplay.rust-lang.org\u002F?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ed5a8cbe8cfab762c32466c551957810\"\u003E在线示例\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E我想你的心里已经有答案了吧。\u003C\u002Fp\u003E\n\u003Ch2\u003E不会用模式匹配\u003C\u002Fh2\u003E\n\u003Cp\u003E让我们回到一开始的 \u003Ccode\u003EIndexOf()\u003C\u002Fcode\u003E 函数，我们用 \u003Ccode\u003EOption\u003C\u002Fcode\u003E 类型举了一个很好的例子，先看下原始代码：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E index = sentence.IndexOf(\u003Cspan class=\"hljs-string\"\u003E&quot;fox&quot;\u003C\u002Fspan\u003E);\n\n\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (index != \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E)\n{\n  \u003Cspan class=\"hljs-built_in\"\u003Estring\u003C\u002Fspan\u003E wordsAfterFox = sentence.SubString(index);\n  Console.WriteLine(wordsAfterFox);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E然后，你可能会看到这样的 Rust 代码：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E opt: \u003Cspan class=\"hljs-built_in\"\u003EOption\u003C\u002Fspan\u003E&lt;_&gt; = ...;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E opt.is_some() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E value = opt.unwrap();\n  ...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E或者这样的：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E list: &amp;[\u003Cspan class=\"hljs-built_in\"\u003Ef32\u003C\u002Fspan\u003E] = ...;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !list.is_empty() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E first = list[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E];\n  ...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这些条件语句都在避免某些边界条件，不过就像之前说到的哨兵值一样，我们在重构的时候依然会极有可能引入 bug。\u003C\u002Fp\u003E\n\u003Cp\u003E而使用 Rust 的模式匹配，你可以保证当且仅当值有效时才会执行到对应的代码：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(value) = opt {\n  ...\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E [first, ..] = list {\n  ...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E相比于之前的代码，由于避免了 \u003Ccode\u003Eopt.unwrap()\u003C\u002Fcode\u003E 和 \u003Ccode\u003Elist[index]\u003C\u002Fcode\u003E，模式匹配可以有更好的性能（作者的一点忠告：不要在网上听风就是雨，如果你真的想知道真相，建议写个 Benchmark 验证下）。\u003C\u002Fp\u003E\n\u003Ch2\u003E别再构造函数后初始化\u003C\u002Fh2\u003E\n\u003Cp\u003E许多语言都会在构造对象后调用对应的初始化函数（\u003Ccode\u003Einit()\u003C\u002Fcode\u003E 之类的），但这有悖于 Rust 的约定：让无效状态不可见。\u003C\u002Fp\u003E\n\u003Cp\u003E假设你在写个 NLP 程序，需要加载一个包含所有关键词的词表：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E dict = Dictionary::new();\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 读取文件并且把值存到哈希表或者列表里\u003C\u002Fspan\u003E\ndict.load_from_file(\u003Cspan class=\"hljs-string\"\u003E&quot;.\u002Fwords.txt&quot;\u003C\u002Fspan\u003E)?;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E然而，如果这么写了，意味着 \u003Ccode\u003EDictionary\u003C\u002Fcode\u003E 类有两个状态：空的和满的。\u003C\u002Fp\u003E\n\u003Cp\u003E那么如果后续代码假设 \u003Ccode\u003EDictionary\u003C\u002Fcode\u003E 有值，并且直接使用它，那当我们错误地对一个空状态的 \u003Ccode\u003EDictionary\u003C\u002Fcode\u003E 进行索引时，就会造成 panic。\u003C\u002Fp\u003E\n\u003Cp\u003E在 Rust 中，最好在构造时就对结构体进行初始化，来避免结构体的空状态。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E dict = Dictionary::from_file(\u003Cspan class=\"hljs-string\"\u003E&quot;.\u002Fwords.txt&quot;\u003C\u002Fspan\u003E)?;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E Dictionary {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Efrom_file\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(filename: \u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EAsRef\u003C\u002Fspan\u003E&lt;Path&gt;) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EResult\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-keyword\"\u003ESelf\u003C\u002Fspan\u003E, Error&gt; {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E text = std::fs::read_to_string(filename)?;\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E words = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E line \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E text.lines() {\n      words.push(line);\n    }\n    \u003Cspan class=\"hljs-literal\"\u003EOk\u003C\u002Fspan\u003E(Dictionary { words })\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EDictionary::from_file()\u003C\u002Fcode\u003E 直接执行了初始化操作，并返回了初始化后的、立即可用的结构体，从而避免了上述问题。\u003C\u002Fp\u003E\n\u003Cp\u003E当然，遇到这种问题的频率因人而异，完全取决于你的编码经验和代码风格。\u003C\u002Fp\u003E\n\u003Cp\u003E一般来讲，函数式语言强调不可变性，所以函数式语言的使用者会天然地掌握这个经验。毕竟当你不能随便改变某个值时，你也不大可能创建一个初始化了一半的变量，然后再用什么其他值去填满它。\u003C\u002Fp\u003E\n\u003Cp\u003E但面向对象的语言就不太一样了，它可能更鼓励你先构造个空对象，然后再调用具体函数初始化它，毕竟对象引用很容易为 \u003Ccode\u003Enull\u003C\u002Fcode\u003E，而且他们也不关心什么可变性之类的玩意儿……现在你知道为啥那些面向对象语言会经常由于 \u003Ccode\u003ENullPointerException\u003C\u002Fcode\u003E 崩溃了吧。\u003C\u002Fp\u003E\n\u003Ch2\u003E保护性拷贝\u003C\u002Fh2\u003E\n\u003Cp\u003E不可变对象的一个显而易见的优点时，你永远可以相信它不会发生变化，而放心地使用它的值。但某些语言，比如 Python 或者 Java，不可变性没有传递性。举个例子，\u003Ccode\u003Ex\u003C\u002Fcode\u003E 是个不可变对象，\u003Ccode\u003Ex.y\u003C\u002Fcode\u003E 却不一定是不可变的，除非显式地定义它的可变性。\u003C\u002Fp\u003E\n\u003Cp\u003E这意味着会出现下面的 Python 代码：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EImmutablePerson\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003E__init__\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, name: \u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E, age: \u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E, addresses: \u003Cspan class=\"hljs-type\"\u003EList\u003C\u002Fspan\u003E[\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E]\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n    self._name = name\n    self._age = age\n    self._addresses = addresses\n\n  \u003Cspan class=\"hljs-comment\"\u003E# 只读属性\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E  @property\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ename\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E self._name\n\u003Cspan class=\"hljs-meta\"\u003E  @property\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eage\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E self._age\n\u003Cspan class=\"hljs-meta\"\u003E  @property\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eaddresses\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E self._addresses\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E后来其他人用了这个号称不可变的 \u003Ccode\u003EImmutablePerson\u003C\u002Fcode\u003E，但是却不小心把它搞乱了：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Esend_letters\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Emessage: \u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E, addresses: \u003Cspan class=\"hljs-type\"\u003EList\u003C\u002Fspan\u003E[\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E]\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E# 注意：发信 api 只接受大写字母，所以这里要预处理\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E i, address \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eenumerate\u003C\u002Fspan\u003E(addresses):\n    addresses[i] = addresses.upper()\n\n  client = PostOfficeClient()\n  client.send_bulk_mail(message, addresses)\n\n\nperson = ImmutablePerson(\u003Cspan class=\"hljs-string\"\u003E&quot;Joe Bloggs&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E42\u003C\u002Fspan\u003E, [\u003Cspan class=\"hljs-string\"\u003E&quot;123 Fake Street&quot;\u003C\u002Fspan\u003E])\n\nsend_letters(\n  \u003Cspan class=\"hljs-string\"\u003Ef&quot;Dear \u003Cspan class=\"hljs-subst\"\u003E{person.name}\u003C\u002Fspan\u003E, I Nigerian prince. Please help me moving my monies.&quot;\u003C\u002Fspan\u003E,\n  person.addresses\n)\n\n\u003Cspan class=\"hljs-built_in\"\u003Eprint\u003C\u002Fspan\u003E(person.addresses) \u003Cspan class=\"hljs-comment\"\u003E# [&quot;123 FAKE STREET&quot;]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我承认，这个例子确实有点刻意了，但是修改一个函数的传参却非常常见（译者按：尤其在某些深度学习项目里）。当你知道你自己定义的 \u003Ccode\u003EImmutablePerson\u003C\u002Fcode\u003E 的 \u003Ccode\u003Eaddresses\u003C\u002Fcode\u003E 属性不可变时，不会有什么大问题，但是当你和别人协作，而且别人还不知道 \u003Ccode\u003Eaddresses\u003C\u002Fcode\u003E 不可变时，那就出大问题了。\u003C\u002Fp\u003E\n\u003Cp\u003E事情也不是无法挽回，解决这个问题的经典方法是，总是在获取属性值的时候，返回它的拷贝，而非它自己：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EImmutablePerson\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n  ...\n\n\u003Cspan class=\"hljs-meta\"\u003E  @property\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eaddresses\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E self._addresses.copy()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这样就可以保证别人在使用该对象的属性时，不会意外改变它的原始值。\u003C\u002Fp\u003E\n\u003Cp\u003E考虑到这篇文章的主题是 Rust，你可能已经猜到了造成这种问题的根本原因：别名与可变性。\u003C\u002Fp\u003E\n\u003Cp\u003E并且你也可能想到，这种情况不会发生在 Rust 中，生命周期机制以及“有且只能有一处可变引用”的机制，保证了程序员无法在取得变量的所有权情况下去改动它的值，也没法显式地使用 \u003Ccode\u003Estd::sync::Mutex&lt;T&gt;\u003C\u002Fcode\u003E 去改变某个共享引用值。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E备注：你可能见过别人用 \u003Ccode\u003E.clone()\u003C\u002Fcode\u003E 来处理借用检查器的报错，然后就大喊“你看，Rust 还不是强迫我们做了保护性拷贝措施？”。我想说的是，这种代码基本都是由于程序员不熟悉生命周期机制，或者代码设计有问题导致的。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2\u003E总结\u003C\u002Fh2\u003E\n\u003Cp\u003E本文并不能覆盖所有的最差实践，有些是因为我没亲身经历过，有些则是由于没法给出精简的例子。\u003C\u002Fp\u003E\n\u003Cp\u003E衷心地感谢回复我在 Rust 论坛发布的\u003Ca href=\"https:\u002F\u002Fusers.rust-lang.org\u002Ft\u002Fcommon-newbie-mistakes-or-bad-practices\u002F64821\u002F8\"\u003E这个帖子\u003C\u002Fa\u003E的各位同仁，尽管帖子的最后有点跑偏，各位 Rust 老鸟的论战还是让我受益颇深。\u003C\u002Fp\u003E\n",should404:false,id:30}},mutations:void 0});