__NUXT_JSONP__("/posts/28", {data:[{}],fetch:{"0":{zoom:null,pageCount:true,title:"树和数组的千层套路",author:"Yidadaa",date:"2020\u002F03\u002F18",content:"\u003Cblockquote\u003E\n\u003Cp\u003E今天教你怎么在线性数组和二叉树间反复横跳。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E目录：\u003C\u002Fp\u003E\n\u003Cul class=\"task-list\"\u003E\n\u003Cli class=\"task-list-item\"\u003E\u003Cinput type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\"\u003E\u003Clabel for=\"cbx_0\"\u003E 二叉堆\u003C\u002Flabel\u003E\u003C\u002Fli\u003E\n\u003Cli class=\"task-list-item\"\u003E\u003Cinput type=\"checkbox\" id=\"cbx_1\" disabled=\"true\"\u003E\u003Clabel for=\"cbx_1\"\u003E 树状数组\u003C\u002Flabel\u003E\u003C\u002Fli\u003E\n\u003Cli class=\"task-list-item\"\u003E\u003Cinput type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\"\u003E\u003Clabel for=\"cbx_2\"\u003E 线段树\u003C\u002Flabel\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E在最简单的一类数据结构中，有两种最为基础：线性数组和树，它们在实际的应用中十分常用，比如线性数组用来存储结构化数据，树用来存储一些有层级归属关系的数据。一个最典型的使用树的场景就是浏览器中的 GUI 渲染策略，在你阅读本篇文章的时候，浏览器就已经从 HTML 文件中解析出当前界面上的所有元素，并按照从属关系依次渲染出来，你只需要按下键盘上的 \u003Ccode\u003EF12\u003C\u002Fcode\u003E 键，就可以看到页面中所有元素的从属关系。\u003C\u002Fp\u003E\n\u003Cp\u003E然而，一般意义上的树并不是高度结构化的数据，虽然一颗树的所有信息都可以由根节点遍历出来，但是在没有提前建立索引的情况下，你很难轻易地直接获取树中任意节点的数据。所以人们为了更高的随机索引速度，会更倾向于使用结构稳定的二叉树，尤其是完全二叉树，这是由于完全二叉树的左右子树高度差不超过 1，其每层的节点数量都是 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmsup\u003E\u003Cmn\u003E2\u003C\u002Fmn\u003E\u003Cmi\u003En\u003C\u002Fmi\u003E\u003C\u002Fmsup\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003E2^n\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord\"\u003E\u003Cspan class=\"mord\"\u003E2\u003C\u002Fspan\u003E\u003Cspan class=\"msupsub\"\u003E\u003Cspan class=\"vlist-t\"\u003E\u003Cspan class=\"vlist-r\"\u003E\u003Cspan class=\"vlist\" style=\"height:0.664392em;\"\u003E\u003Cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003E\u003Cspan class=\"pstrut\" style=\"height:2.7em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"sizing reset-size6 size3 mtight\"\u003E\u003Cspan class=\"mord mathnormal mtight\"\u003En\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E ，所以完全二叉树可以很轻松地存储在线性数组里，然后通过 \u003Ccode\u003Echild = tree[parent_index * 2]\u003C\u002Fcode\u003E 的方式去递推任意孩子节点的索引值。\u003C\u002Fp\u003E\n\u003Cp\u003E二叉树的这种特性使得树状结构可以很方便地存储在线性数组中，而本文就将阐述那些和线性数组关系紧密的树状数据结构们。\u003C\u002Fp\u003E\n\u003Ch2\u003E二叉堆\u003C\u002Fh2\u003E\n\u003Cp\u003E在使用二叉堆之前，你需要知道什么是堆，以及为什么要有堆。\u003C\u002Fp\u003E\n\u003Cp\u003E根据\u003Ca href=\"https:\u002F\u002Fzh.wikipedia.org\u002Fwiki\u002F%E5%A0%86%E7%A9%8D\"\u003E维基百科\u003C\u002Fa\u003E的描述，堆是一种具有特殊顺序的树，也就是说，堆就是一种树，就像二叉搜索树那样，堆的节点间也有一些大小关系，最常用的堆是\u003Cstrong\u003E最大堆\u003C\u002Fstrong\u003E和\u003Cstrong\u003E最小堆\u003C\u002Fstrong\u003E，又称大（小）顶堆、大（小）根堆等，以最大堆为例，最大堆中的任意一个节点都比它的子节点的值更大，也就是说，堆的根节点的元素是整个堆的最大值，值得注意的是，这种大小约束只对父节点和子节点生效，而相同层级的节点不需要有大小关系上的约束。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F16968934\u002F77818922-a1bb2280-7111-11ea-8eef-a4c8ab7e5783.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E除此之外，堆还必须是一颗完全二叉树，这可以保证对堆的各种操作的均摊复杂度最低。\u003C\u002Fp\u003E\n\u003Cp\u003E但是你可能会依然很疑惑，就像我在数据结构课上听到一个全新的数据结构的时候，心里会想：“wow, awesome, 然后呢？”，人们造出来拥有很多复杂结构的事物，并不是完全为了消磨时间，而是因为为了解决问题而不得不让这些工具变得这么复杂，本文中提到的三种数据结构也是如此，它们本身的特性使得它们在解决某些问题时异常好用。\u003C\u002Fp\u003E\n\u003Cp\u003E而堆的最常用例子就是优先队列，你可以看到堆的根节点始终是最大值或者最小值，这种最值可以以优先级的形式体现出来，而且这种极值顺序会在动态增减的过程中始终以 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003EO\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E(\u003C\u002Fmo\u003E\u003Cmi\u003El\u003C\u002Fmi\u003E\u003Cmi\u003Eo\u003C\u002Fmi\u003E\u003Cmi\u003Eg\u003C\u002Fmi\u003E\u003Cmi\u003EN\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E)\u003C\u002Fmo\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003EO(log N)\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.02778em;\"\u003EO\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.01968em;\"\u003El\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Eo\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.03588em;\"\u003Eg\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003EN\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E 的时间复杂度保持着，回想一下，如果你要对一个普通的线性数组取极大值，你就不得不付出 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003EO\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E(\u003C\u002Fmo\u003E\u003Cmi\u003EN\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E)\u003C\u002Fmo\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003EO(N)\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.02778em;\"\u003EO\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003EN\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E 的时间复杂度。堆的特性可以大大降低很多需要动态维护优先级的算法的复杂度，比如原始的\u003Ca href=\"https:\u002F\u002Fzh.wikipedia.org\u002Fwiki\u002F%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\"\u003E迪杰斯特拉最短路径算法\u003C\u002Fa\u003E的时间复杂度是 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003EO\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E(\u003C\u002Fmo\u003E\u003Cmsup\u003E\u003Cmi\u003EN\u003C\u002Fmi\u003E\u003Cmn\u003E2\u003C\u002Fmn\u003E\u003C\u002Fmsup\u003E\u003Cmo stretchy=\"false\"\u003E)\u003C\u002Fmo\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003EO(N^2)\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.02778em;\"\u003EO\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mord\"\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003EN\u003C\u002Fspan\u003E\u003Cspan class=\"msupsub\"\u003E\u003Cspan class=\"vlist-t\"\u003E\u003Cspan class=\"vlist-r\"\u003E\u003Cspan class=\"vlist\" style=\"height:0.8141079999999999em;\"\u003E\u003Cspan style=\"top:-3.063em;margin-right:0.05em;\"\u003E\u003Cspan class=\"pstrut\" style=\"height:2.7em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"sizing reset-size6 size3 mtight\"\u003E\u003Cspan class=\"mord mtight\"\u003E2\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E，而使用堆优化后可以达到 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003EO\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E(\u003C\u002Fmo\u003E\u003Cmi\u003EN\u003C\u002Fmi\u003E\u003Cmi\u003El\u003C\u002Fmi\u003E\u003Cmi\u003Eo\u003C\u002Fmi\u003E\u003Cmi\u003Eg\u003C\u002Fmi\u003E\u003Cmi\u003EN\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E)\u003C\u002Fmo\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003EO(N logN)\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.02778em;\"\u003EO\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003EN\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.01968em;\"\u003El\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Eo\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.03588em;\"\u003Eg\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003EN\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E现在你知道了什么是堆，以及堆用来解决那些问题，下面就介绍一下堆的常用操作，本文所述的堆均代表二叉堆。\u003C\u002Fp\u003E\n\u003Cp\u003E二叉堆通常存储在一个数组中，而堆的插入（insert）、弹出（pop）、取堆顶（top）、删除（remove）操作均可以通过不断交换数组元素来完成，而这些操作均有两个最基础的操作组成：向上调整（up）和向下调整（down），顾名思义，向上调整就是从当前节点开始向根节点遍历，确认该路径上所有节点是否满足“子节点小于（大于）父节点”的顺序，如果不满足，则进行调整；而向下调整则是向叶子节点进行遍历，然后执行同样的操作，写成代码形式（以最大堆为例）：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EHeap\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003E__init__\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n    self.heap = []\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eswap\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, i, j\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n    self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eup\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, k\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;&#x27;向上调整第 k 个节点&#x27;&#x27;&#x27;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E k &gt; \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E:\n        parent_index = (k - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) \u002F\u002F \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-comment\"\u003E# 如果子节点大于父节点，则进行调整\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E self.heap[k] &gt; self.heap[parent_index]:\n          self.swap(k, parent_index)\n        \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Edown\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, k\u003C\u002Fspan\u003E)\n    &#x27;&#x27;&#x27;向下调整第 \u003Cspan class=\"hljs-title\"\u003Ek\u003C\u002Fspan\u003E 个节点&#x27;&#x27;&#x27;\n    \u003Cspan class=\"hljs-title\"\u003Ewhile\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ek\u003C\u002Fspan\u003E &lt; \u003Cspan class=\"hljs-title\"\u003Elen\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself.heap\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n      lchild, rchild = k * \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, k * \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E# 两个子节点取较大节点\u003C\u002Fspan\u003E\n      child = lchild \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E self.heap[lchild] &gt; self.heap[rchild] \u003Cspan class=\"hljs-keyword\"\u003Eor\u003C\u002Fspan\u003E rchild &gt; \u003Cspan class=\"hljs-built_in\"\u003Elen\u003C\u002Fspan\u003E(self.heap) \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E rchild\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E child &lt; \u003Cspan class=\"hljs-built_in\"\u003Elen\u003C\u002Fspan\u003E(self.heap) \u003Cspan class=\"hljs-keyword\"\u003Eand\u003C\u002Fspan\u003E self.heap[child] &gt; self.heap[k]:\n        self.swap(child, k)\n        k = child\n      \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以看到，调整部分的代码的逻辑还是比较清晰的，只需要不断向上或者向下遍历，然后调整对应的值即可。有了两个基础操作，我们可以很方便地完成插入、弹出、取顶、删除等操作了，直接看代码：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EHeap\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;&#x27;省略 up, down 部分的代码&#x27;&#x27;&#x27;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Einsert\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, val\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;&#x27;将 val 插入堆中&#x27;&#x27;&#x27;\u003C\u002Fspan\u003E\n    self.heap.append(val) \u003Cspan class=\"hljs-comment\"\u003E# 插到数组尾部\u003C\u002Fspan\u003E\n    self.up(\u003Cspan class=\"hljs-built_in\"\u003Elen\u003C\u002Fspan\u003E(self.heap) - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E# 然后不断向上调整即可\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Etop\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;&#x27;获取堆顶值&#x27;&#x27;&#x27;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Elen\u003C\u002Fspan\u003E(self.heap) == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E self.heap[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E] \u003Cspan class=\"hljs-comment\"\u003E# 只需返回数组中的第一个元素即可\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eremove\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, k\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;&#x27;移除第 k 个节点&#x27;&#x27;&#x27;\u003C\u002Fspan\u003E\n    self.swap(k, \u003Cspan class=\"hljs-built_in\"\u003Elen\u003C\u002Fspan\u003E(self.heap) - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E# 将第 k 个元素交换到尾部\u003C\u002Fspan\u003E\n    ret = self.heap.pop() \u003Cspan class=\"hljs-comment\"\u003E# 将其从数组中删除\u003C\u002Fspan\u003E\n    self.up(k) \u003Cspan class=\"hljs-comment\"\u003E# 确认是否需要向上调整\u003C\u002Fspan\u003E\n    self.down(k) \u003Cspan class=\"hljs-comment\"\u003E# 确认是否需要向下调整\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E ret\n\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Epop\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;&#x27;弹出堆顶&#x27;&#x27;&#x27;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E self.remove(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E掌握了二叉堆，我们可以很轻松地解决 TOP-k 问题，以及所有需要使用到优先队列的问题，不过值得一提的是，二叉堆作为一种非常常用的数据结构，已经被内置到很多语言的官方库中，在实际使用或者写算法题时，可以直接调包使用，比如 Python3 的 \u003Ccode\u003Equeue.PriorityQueue\u003C\u002Fcode\u003E 和 \u003Ccode\u003Eheapq\u003C\u002Fcode\u003E，以及 C++ 的 \u003Ccode\u003Epriority_queue\u003C\u002Fcode\u003E 等。\u003C\u002Fp\u003E\n\u003Ch2\u003E线段树和树状数组\u003C\u002Fh2\u003E\n\u003Cp\u003E线段树和树状数组非常像，可以说树状数组就是线段树的一种简化形式，在应对单点修改的区间问题时，树状数组更为简洁好用，但由于使用了 \u003Ccode\u003Elow-bit\u003C\u002Fcode\u003E 技巧，相对来说并没有线段树容易理解，所以本文就先从线段树的原理讲起，再逐步扩展到树状数组。\u003C\u002Fp\u003E\n\u003Cp\u003E首先，我们用一个例题来作为切入概念：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E来源：\u003Ca href=\"https:\u002F\u002Fleetcode-cn.com\u002Fproblems\u002Frange-sum-query-immutable\u002F\"\u003E303. 区域和检索 - 数组不可变\u003C\u002Fa\u003E\n给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E下面是一些示例，给定 \u003Ccode\u003Enums = [-2, 0, 3, -5, 2, -1]\u003C\u002Fcode\u003E，那么对任意的 \u003Ccode\u003E(i, j)\u003C\u002Fcode\u003E 进行求和：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003EsumRange(0, 2) -&gt; 1\nsumRange(2, 5) -&gt; -1\nsumRange(0, 5) -&gt; -3\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我们可以很容易地想到 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Eo\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E(\u003C\u002Fmo\u003E\u003Cmi\u003EN\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E)\u003C\u002Fmo\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003Eo(N)\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Eo\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003EN\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E 的解法，直接对区间 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmo stretchy=\"false\"\u003E[\u003C\u002Fmo\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003Cmi mathvariant=\"normal\"\u003E.\u003C\u002Fmi\u003E\u003Cmi mathvariant=\"normal\"\u003E.\u003C\u002Fmi\u003E\u003Cmi mathvariant=\"normal\"\u003E.\u003C\u002Fmi\u003E\u003Cmi\u003Ej\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E]\u003C\u002Fmo\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003E[i ... j]\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E[\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Ei\u003C\u002Fspan\u003E\u003Cspan class=\"mord\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"mord\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"mord\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.05724em;\"\u003Ej\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E]\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E 的数进行求和即可，但是当查询次数很大时，很容易就会超时，而如果我们使用前缀和数组，就可以轻松地在 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Eo\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E(\u003C\u002Fmo\u003E\u003Cmn\u003E1\u003C\u002Fmn\u003E\u003Cmo stretchy=\"false\"\u003E)\u003C\u002Fmo\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003Eo(1)\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Eo\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mord\"\u003E1\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E 时间内完成任何查询操作，所谓的前缀和数组，就是把前 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003Ei\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Ei\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E 位的数字加起来作为第 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003Ei\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Ei\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E 位的元素值，即 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Es\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E[\u003C\u002Fmo\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E]\u003C\u002Fmo\u003E\u003Cmo\u003E=\u003C\u002Fmo\u003E\u003Cmsubsup\u003E\u003Cmo\u003E∑\u003C\u002Fmo\u003E\u003Cmrow\u003E\u003Cmi\u003Ej\u003C\u002Fmi\u003E\u003Cmo\u003E=\u003C\u002Fmo\u003E\u003Cmn\u003E0\u003C\u002Fmn\u003E\u003C\u002Fmrow\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003C\u002Fmsubsup\u003E\u003Cmsub\u003E\u003Cmi\u003Ea\u003C\u002Fmi\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003C\u002Fmsub\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003Es[i] = \\sum_{j=0}^i a_i\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Es\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E[\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Ei\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E]\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mrel\"\u003E=\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1.400382em;vertical-align:-0.43581800000000004em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mop\"\u003E\u003Cspan class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\"\u003E∑\u003C\u002Fspan\u003E\u003Cspan class=\"msupsub\"\u003E\u003Cspan class=\"vlist-t vlist-t2\"\u003E\u003Cspan class=\"vlist-r\"\u003E\u003Cspan class=\"vlist\" style=\"height:0.964564em;\"\u003E\u003Cspan style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"\u003E\u003Cspan class=\"pstrut\" style=\"height:2.7em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"sizing reset-size6 size3 mtight\"\u003E\u003Cspan class=\"mord mtight\"\u003E\u003Cspan class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\"\u003Ej\u003C\u002Fspan\u003E\u003Cspan class=\"mrel mtight\"\u003E=\u003C\u002Fspan\u003E\u003Cspan class=\"mord mtight\"\u003E0\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan style=\"top:-3.2029em;margin-right:0.05em;\"\u003E\u003Cspan class=\"pstrut\" style=\"height:2.7em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"sizing reset-size6 size3 mtight\"\u003E\u003Cspan class=\"mord mathnormal mtight\"\u003Ei\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"vlist-s\"\u003E​\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"vlist-r\"\u003E\u003Cspan class=\"vlist\" style=\"height:0.43581800000000004em;\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord\"\u003E\u003Cspan class=\"mord mathnormal\"\u003Ea\u003C\u002Fspan\u003E\u003Cspan class=\"msupsub\"\u003E\u003Cspan class=\"vlist-t vlist-t2\"\u003E\u003Cspan class=\"vlist-r\"\u003E\u003Cspan class=\"vlist\" style=\"height:0.31166399999999994em;\"\u003E\u003Cspan style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"\u003E\u003Cspan class=\"pstrut\" style=\"height:2.7em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"sizing reset-size6 size3 mtight\"\u003E\u003Cspan class=\"mord mathnormal mtight\"\u003Ei\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"vlist-s\"\u003E​\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"vlist-r\"\u003E\u003Cspan class=\"vlist\" style=\"height:0.15em;\"\u003E\u003Cspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E，代码表示如下：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Esolve\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Enums\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n  s = [\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E] + nums\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E i \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Erange\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-built_in\"\u003Elen\u003C\u002Fspan\u003E(nums) + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E):\n    s[i] += s[i - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E对于本例，可以算出前缀和数组，为了方便计算，我们往数组前部插入一个零，有了前缀数组，我们就可以使用 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Es\u003C\u002Fmi\u003E\u003Cmi\u003Eu\u003C\u002Fmi\u003E\u003Cmi\u003Em\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E(\u003C\u002Fmo\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003Cmo separator=\"true\"\u003E,\u003C\u002Fmo\u003E\u003Cmi\u003Ej\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E)\u003C\u002Fmo\u003E\u003Cmo\u003E=\u003C\u002Fmo\u003E\u003Cmi\u003Es\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E[\u003C\u002Fmo\u003E\u003Cmi\u003Ej\u003C\u002Fmi\u003E\u003Cmo\u003E+\u003C\u002Fmo\u003E\u003Cmn\u003E1\u003C\u002Fmn\u003E\u003Cmo stretchy=\"false\"\u003E]\u003C\u002Fmo\u003E\u003Cmo\u003E−\u003C\u002Fmo\u003E\u003Cmi\u003Es\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E[\u003C\u002Fmo\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E]\u003C\u002Fmo\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003Esum(i, j) = s[j + 1] - s[i]\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Es\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Eu\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Em\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Ei\u003C\u002Fspan\u003E\u003Cspan class=\"mpunct\"\u003E,\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.05724em;\"\u003Ej\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mrel\"\u003E=\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Es\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E[\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.05724em;\"\u003Ej\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mbin\"\u003E+\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord\"\u003E1\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E]\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mbin\"\u003E−\u003C\u002Fspan\u003E\u003Cspan class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Es\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E[\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Ei\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E]\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E 来计算任意区间的和了：\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Es = [0, -2, -2, 1, -4, -2, -3]\nsumRange(0, 2) = s[3] - s[0] = 1 - 0 = 1\nsumRange(2, 5) = s[6] - s[2] = -3 - (-2) = -1\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以看到，数组的区间信息可以压缩成更紧凑的形式。对于此例题中的静态数组，前缀和应对起来绰绰有余，但是如果在查询过程中数组的数据发生了变化，我们就不得不在每次变化的时候花上 \u003Cspan class=\"katex\"\u003E\u003Cspan class=\"katex-mathml\"\u003E\u003Cmath xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Eo\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E(\u003C\u002Fmo\u003E\u003Cmi\u003EN\u003C\u002Fmi\u003E\u003Cmo stretchy=\"false\"\u003E)\u003C\u002Fmo\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\"application\u002Fx-tex\"\u003Eo(N)\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"katex-html\" aria-hidden=\"true\"\u003E\u003Cspan class=\"base\"\u003E\u003Cspan class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\"\u003Eo\u003C\u002Fspan\u003E\u003Cspan class=\"mopen\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"mord mathnormal\" style=\"margin-right:0.10903em;\"\u003EN\u003C\u002Fspan\u003E\u003Cspan class=\"mclose\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E 的 时间开销去更新前缀数组，比如下面这道例题。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E来源：\u003Ca href=\"https:\u002F\u002Fleetcode-cn.com\u002Fproblems\u002Frange-sum-query-mutable\u002F\"\u003E307. 区域和检索 - 数组可修改\u003C\u002Fa\u003E\n给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。\nupdate(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E前缀和的本质是维护区间信息，但在应对可变数组时的灵活性太差，所以我们使用更强大的线段树来解决这个问题。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F16968934\u002F79983584-940f7780-84da-11ea-8882-a06db59b8056.png\" alt=\"image\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E上图表示了线段树的结构，线段树本质上是一个二叉树，它通过不断地把数组二分的方式来从根节点向叶子节点扩展，每个节点都维护了一个区间内的数组信息，这个数组信息可以是区间内的数组和以及最大最小值。\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ENode\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003E__init__\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, l, r\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n        self.l = l\n        self.r = r\n        self.lchild = \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E\n        self.rchild = \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E\n        self.val = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ENumArray\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003E__init__\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, nums: \u003Cspan class=\"hljs-type\"\u003EList\u003C\u002Fspan\u003E[\u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E]\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n        self.nums = nums\n        self.tree = self.build(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-built_in\"\u003Elen\u003C\u002Fspan\u003E(nums) - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E)\n \n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ebuild\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, l, r\u003C\u002Fspan\u003E):\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E l &gt; r: \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E\n        node = Node(l, r)\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E l == r:\n            node.val = self.nums[l]\n            \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E node\n        m = (l + r) &gt;&gt; \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\n        node.lchild = self.build(l, m)\n        node.rchild = self.build(m + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, r)\n        node.val = node.lchild.val + node.rchild.val\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E node\n\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eupdate\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, i: \u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E, val: \u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n        d = val - self.nums[i]\n        self.nums[i] = val\n        q = [self.tree]\n        \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E q:\n            node = q.pop()\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E i &gt;= node.l \u003Cspan class=\"hljs-keyword\"\u003Eand\u003C\u002Fspan\u003E i &lt;= node.r: node.val += d\n            \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E child \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E [node.lchild, node.rchild]:\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E child: q.append(child)\n\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EsumRange\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Eself, i: \u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E, j: \u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003Eint\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E\n        ret = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n        q = [self.tree]\n        \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E q:\n            node = q.pop()\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enot\u003C\u002Fspan\u003E node: \u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E node.l &gt;= i \u003Cspan class=\"hljs-keyword\"\u003Eand\u003C\u002Fspan\u003E node.r &lt;= j:\n                ret += node.val\n            \u003Cspan class=\"hljs-keyword\"\u003Eelif\u003C\u002Fspan\u003E node.l &lt; j:\n                q.append(node.lchild)\n            \u003Cspan class=\"hljs-keyword\"\u003Eelif\u003C\u002Fspan\u003E node.r &gt; i:\n                q.append(node.rchild)\n        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E ret\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E[未完待续]\u003C\u002Fp\u003E\n",should404:false,id:28}},mutations:void 0});