<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>树和数组的千层套路 | YiFei Zhang&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="stylesheet" href="https://cdn.bootcss.com/prism/9000.0.1/themes/prism.min.css">
    <link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.5.1/katex.min.css">
    <script charset="utf-8" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="true"></script>
    <link rel="icon" type="image/png" href="https://avatars2.githubusercontent.com/u/16968934?s=460&amp;v=4">
    <meta name="description" content="在这里了解我的一切，对编程的热爱永不停歇。">
    
    <link rel="preload" href="/assets/css/0.styles.41aafd19.css" as="style"><link rel="preload" href="/assets/js/app.ac476203.js" as="script"><link rel="preload" href="/assets/js/11.cfdfc7a9.js" as="script"><link rel="preload" href="/assets/js/6.e85e9b95.js" as="script"><link rel="preload" href="/assets/js/2.2db01773.js" as="script"><link rel="preload" href="/assets/js/33.19947ba8.js" as="script"><link rel="preload" href="/assets/js/5.63cd31eb.js" as="script"><link rel="prefetch" href="/assets/js/10.d74ccdb9.js"><link rel="prefetch" href="/assets/js/12.e872fa5c.js"><link rel="prefetch" href="/assets/js/13.4b8c6207.js"><link rel="prefetch" href="/assets/js/14.560a2285.js"><link rel="prefetch" href="/assets/js/15.3de6234a.js"><link rel="prefetch" href="/assets/js/16.d1732f2d.js"><link rel="prefetch" href="/assets/js/17.6624a940.js"><link rel="prefetch" href="/assets/js/18.a706c3da.js"><link rel="prefetch" href="/assets/js/19.b6d5c907.js"><link rel="prefetch" href="/assets/js/20.8af53fc0.js"><link rel="prefetch" href="/assets/js/21.20bc0802.js"><link rel="prefetch" href="/assets/js/22.eb4500b4.js"><link rel="prefetch" href="/assets/js/23.55f18fd5.js"><link rel="prefetch" href="/assets/js/24.ea067f0e.js"><link rel="prefetch" href="/assets/js/25.9bd5f028.js"><link rel="prefetch" href="/assets/js/26.1ffb8c60.js"><link rel="prefetch" href="/assets/js/27.d21a5a75.js"><link rel="prefetch" href="/assets/js/28.1b8a205b.js"><link rel="prefetch" href="/assets/js/29.5a26b6c6.js"><link rel="prefetch" href="/assets/js/3.d6efb051.js"><link rel="prefetch" href="/assets/js/30.f9e47e7a.js"><link rel="prefetch" href="/assets/js/31.2eb4f3ad.js"><link rel="prefetch" href="/assets/js/32.b43b04db.js"><link rel="prefetch" href="/assets/js/34.f56b2dec.js"><link rel="prefetch" href="/assets/js/35.51481dd2.js"><link rel="prefetch" href="/assets/js/36.078b17d1.js"><link rel="prefetch" href="/assets/js/37.6769b0a2.js"><link rel="prefetch" href="/assets/js/38.93cf6e97.js"><link rel="prefetch" href="/assets/js/39.fdbe8063.js"><link rel="prefetch" href="/assets/js/4.a07e338a.js"><link rel="prefetch" href="/assets/js/40.3b27870e.js"><link rel="prefetch" href="/assets/js/41.7ddeb732.js"><link rel="prefetch" href="/assets/js/42.fc520c1b.js"><link rel="prefetch" href="/assets/js/7.279a0040.js"><link rel="prefetch" href="/assets/js/8.c65b2727.js"><link rel="prefetch" href="/assets/js/9.317389b9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.41aafd19.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="header-wrap" data-v-33920667><div class="header page" data-v-33920667><div class="left" data-v-33920667><div class="motto" data-v-33920667></div> <div class="nav" data-v-33920667></div></div> <div class="right" data-v-33920667><div class="search-box" data-v-33920667><input aria-label="Search" placeholder="" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></div> <div class="page post-page"><div class="title"><div class="post-title">树和数组的千层套路</div></div> <div class="info"><div class="author">Yidadaa</div> <div class="date">2020/03/18</div> <div class="count"><span id="busuanzi_value_page_pv"></span> <span>views</span></div></div> <div class="post-content"><div class="content__default"><h1 id="树和数组的千层套路"><a href="#树和数组的千层套路" class="header-anchor">#</a> 树和数组的千层套路</h1> <blockquote><p>今天教你怎么在线性数组和二叉树间反复横跳。</p></blockquote> <p>目录：</p> <ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_0" checked="checked" disabled="disabled"><label for="cbx_0"> 二叉堆</label></li> <li class="task-list-item"><input type="checkbox" id="cbx_1" disabled="disabled"><label for="cbx_1"> 树状数组</label></li> <li class="task-list-item"><input type="checkbox" id="cbx_2" checked="checked" disabled="disabled"><label for="cbx_2"> 线段树</label></li></ul> <p>在最简单的一类数据结构中，有两种最为基础：线性数组和树，它们在实际的应用中十分常用，比如线性数组用来存储结构化数据，树用来存储一些有层级归属关系的数据。一个最典型的使用树的场景就是浏览器中的 GUI 渲染策略，在你阅读本篇文章的时候，浏览器就已经从 HTML 文件中解析出当前界面上的所有元素，并按照从属关系依次渲染出来，你只需要按下键盘上的 <code>F12</code> 键，就可以看到页面中所有元素的从属关系。</p> <p>然而，一般意义上的树并不是高度结构化的数据，虽然一颗树的所有信息都可以由根节点遍历出来，但是在没有提前建立索引的情况下，你很难轻易地直接获取树中任意节点的数据。所以人们为了更高的随机索引速度，会更倾向于使用结构稳定的二叉树，尤其是完全二叉树，这是由于完全二叉树的左右子树高度差不超过 1，其每层的节点数量都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> ，所以完全二叉树可以很轻松地存储在线性数组里，然后通过 <code>child = tree[parent_index * 2]</code> 的方式去递推任意孩子节点的索引值。</p> <p>二叉树的这种特性使得树状结构可以很方便地存储在线性数组中，而本文就将阐述那些和线性数组关系紧密的树状数据结构们。</p> <h2 id="二叉堆"><a href="#二叉堆" class="header-anchor">#</a> 二叉堆</h2> <p>在使用二叉堆之前，你需要知道什么是堆，以及为什么要有堆。</p> <p>根据<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D" target="_blank" rel="noopener noreferrer">维基百科<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的描述，堆是一种具有特殊顺序的树，也就是说，堆就是一种树，就像二叉搜索树那样，堆的节点间也有一些大小关系，最常用的堆是<strong>最大堆</strong>和<strong>最小堆</strong>，又称大（小）顶堆、大（小）根堆等，以最大堆为例，最大堆中的任意一个节点都比它的子节点的值更大，也就是说，堆的根节点的元素是整个堆的最大值，值得注意的是，这种大小约束只对父节点和子节点生效，而相同层级的节点不需要有大小关系上的约束。</p> <p><img src="https://user-images.githubusercontent.com/16968934/77818922-a1bb2280-7111-11ea-8eef-a4c8ab7e5783.png" alt="image"></p> <p>除此之外，堆还必须是一颗完全二叉树，这可以保证对堆的各种操作的均摊复杂度最低。</p> <p>但是你可能会依然很疑惑，就像我在数据结构课上听到一个全新的数据结构的时候，心里会想：“wow, awesome, 然后呢？”，人们造出来拥有很多复杂结构的事物，并不是完全为了消磨时间，而是因为为了解决问题而不得不让这些工具变得这么复杂，本文中提到的三种数据结构也是如此，它们本身的特性使得它们在解决某些问题时异常好用。</p> <p>而堆的最常用例子就是优先队列，你可以看到堆的根节点始终是最大值或者最小值，这种最值可以以优先级的形式体现出来，而且这种极值顺序会在动态增减的过程中始终以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间复杂度保持着，回想一下，如果你要对一个普通的线性数组取极大值，你就不得不付出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间复杂度。堆的特性可以大大降低很多需要动态维护优先级的算法的复杂度，比如原始的<a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="noopener noreferrer">迪杰斯特拉最短路径算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，而使用堆优化后可以达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N logN)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p> <p>现在你知道了什么是堆，以及堆用来解决那些问题，下面就介绍一下堆的常用操作，本文所述的堆均代表二叉堆。</p> <p>二叉堆通常存储在一个数组中，而堆的插入（insert）、弹出（pop）、取堆顶（top）、删除（remove）操作均可以通过不断交换数组元素来完成，而这些操作均有两个最基础的操作组成：向上调整（up）和向下调整（down），顾名思义，向上调整就是从当前节点开始向根节点遍历，确认该路径上所有节点是否满足“子节点小于（大于）父节点”的顺序，如果不满足，则进行调整；而向下调整则是向叶子节点进行遍历，然后执行同样的操作，写成代码形式（以最大堆为例）：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>heap <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

  <span class="token keyword">def</span> <span class="token function">up</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''向上调整第 k 个节点'''</span>
    <span class="token keyword">while</span> k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        parent_index <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        <span class="token comment"># 如果子节点大于父节点，则进行调整</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>parent_index<span class="token punctuation">]</span><span class="token punctuation">:</span>
          self<span class="token punctuation">.</span>swap<span class="token punctuation">(</span>k<span class="token punctuation">,</span> parent_index<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">break</span>

  <span class="token keyword">def</span> <span class="token function">down</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
    <span class="token triple-quoted-string string">'''向下调整第 k 个节点'''</span>
    <span class="token keyword">while</span> k <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span><span class="token punctuation">:</span>
      lchild<span class="token punctuation">,</span> rchild <span class="token operator">=</span> k <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>
      <span class="token comment"># 两个子节点取较大节点</span>
      child <span class="token operator">=</span> lchild <span class="token keyword">if</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>lchild<span class="token punctuation">]</span> <span class="token operator">&gt;</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>rchild<span class="token punctuation">]</span> <span class="token keyword">or</span> rchild <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token keyword">else</span> rchild
      <span class="token keyword">if</span> child <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&gt;</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>swap<span class="token punctuation">(</span>child<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
        k <span class="token operator">=</span> child
      <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">break</span>
</code></pre></div><p>可以看到，调整部分的代码的逻辑还是比较清晰的，只需要不断向上或者向下遍历，然后调整对应的值即可。有了两个基础操作，我们可以很方便地完成插入、弹出、取顶、删除等操作了，直接看代码：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">'''省略 up, down 部分的代码'''</span>
  <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''将 val 插入堆中'''</span>
    self<span class="token punctuation">.</span>heap<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment"># 插到数组尾部</span>
    self<span class="token punctuation">.</span>up<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 然后不断向上调整即可</span>

  <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''获取堆顶值'''</span>
    <span class="token keyword">return</span> <span class="token boolean">None</span> <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># 只需返回数组中的第一个元素即可</span>

  <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''移除第 k 个节点'''</span>
    self<span class="token punctuation">.</span>swap<span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 将第 k 个元素交换到尾部</span>
    ret <span class="token operator">=</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 将其从数组中删除</span>
    self<span class="token punctuation">.</span>up<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token comment"># 确认是否需要向上调整</span>
    self<span class="token punctuation">.</span>down<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token comment"># 确认是否需要向下调整</span>
    <span class="token keyword">return</span> ret

  <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''弹出堆顶'''</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><p>掌握了二叉堆，我们可以很轻松地解决 TOP-k 问题，以及所有需要使用到优先队列的问题，不过值得一提的是，二叉堆作为一种非常常用的数据结构，已经被内置到很多语言的官方库中，在实际使用或者写算法题时，可以直接调包使用，比如 Python3 的 <code>queue.PriorityQueue</code> 和 <code>heapq</code>，以及 C++ 的 <code>priority_queue</code> 等。</p> <h2 id="线段树和树状数组"><a href="#线段树和树状数组" class="header-anchor">#</a> 线段树和树状数组</h2> <p>线段树和树状数组非常像，可以说树状数组就是线段树的一种简化形式，在应对单点修改的区间问题时，树状数组更为简洁好用，但由于使用了 <code>low-bit</code> 技巧，相对来说并没有线段树容易理解，所以本文就先从线段树的原理讲起，再逐步扩展到树状数组。</p> <p>首先，我们用一个例题来作为切入概念：</p> <blockquote><p>来源：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener noreferrer">303. 区域和检索 - 数组不可变<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p></blockquote> <p>下面是一些示例，给定 <code>nums = [-2, 0, 3, -5, 2, -1]</code>，那么对任意的 <code>(i, j)</code> 进行求和：</p> <div class="language- extra-class"><pre class="language-text"><code>sumRange(0, 2) -&gt; 1
sumRange(2, 5) -&gt; -1
sumRange(0, 5) -&gt; -3
</code></pre></div><p>我们可以很容易地想到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">o(N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">o</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的解法，直接对区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i ... j]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit">i</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 的数进行求和即可，但是当查询次数很大时，很容易就会超时，而如果我们使用前缀和数组，就可以轻松地在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">o(1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">o</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> 时间内完成任何查询操作，所谓的前缀和数组，就是把前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 位的数字加起来作为第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 位的元素值，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s[i] = \sum_{j=0}^i a_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.825664em;"></span><span class="strut bottom" style="height:1.261782em;vertical-align:-0.436118em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mrel">=</span><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.30001em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span><span style="top:-0.364em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，代码表示如下：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
  s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums
  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
</code></pre></div><p>对于本例，可以算出前缀和数组，为了方便计算，我们往数组前部插入一个零，有了前缀数组，我们就可以使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>=</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum(i, j) = s[j + 1] - s[i]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 来计算任意区间的和了：</p> <div class="language- extra-class"><pre class="language-text"><code>s = [0, -2, -2, 1, -4, -2, -3]
sumRange(0, 2) = s[3] - s[0] = 1 - 0 = 1
sumRange(2, 5) = s[6] - s[2] = -3 - (-2) = -1
</code></pre></div><p>可以看到，数组的区间信息可以压缩成更紧凑的形式。对于此例题中的静态数组，前缀和应对起来绰绰有余，但是如果在查询过程中数组的数据发生了变化，我们就不得不在每次变化的时候花上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">o(N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">o</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的 时间开销去更新前缀数组，比如下面这道例题。</p> <blockquote><p>来源：<a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener noreferrer">307. 区域和检索 - 数组可修改<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。
update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。</p></blockquote> <p>前缀和的本质是维护区间信息，但在应对可变数组时的灵活性太差，所以我们使用更强大的线段树来解决这个问题。</p> <p><img src="https://user-images.githubusercontent.com/16968934/79983584-940f7780-84da-11ea-8882-a06db59b8056.png" alt="image"></p> <p>上图表示了线段树的结构，线段树本质上是一个二叉树，它通过不断地把数组二分的方式来从根节点向叶子节点扩展，每个节点都维护了一个区间内的数组信息，这个数组信息可以是区间内的数组和以及最大最小值。</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>l <span class="token operator">=</span> l
        self<span class="token punctuation">.</span>r <span class="token operator">=</span> r
        self<span class="token punctuation">.</span>lchild <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>rchild <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">class</span> <span class="token class-name">NumArray</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>nums <span class="token operator">=</span> nums
        self<span class="token punctuation">.</span>tree <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
 
    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> l <span class="token operator">&gt;</span> r<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">None</span>
        node <span class="token operator">=</span> Node<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
        <span class="token keyword">if</span> l <span class="token operator">==</span> r<span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>val <span class="token operator">=</span> self<span class="token punctuation">.</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>
            <span class="token keyword">return</span> node
        m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span>
        node<span class="token punctuation">.</span>lchild <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>l<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
        node<span class="token punctuation">.</span>rchild <span class="token operator">=</span> self<span class="token punctuation">.</span>build<span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
        node<span class="token punctuation">.</span>val <span class="token operator">=</span> node<span class="token punctuation">.</span>lchild<span class="token punctuation">.</span>val <span class="token operator">+</span> node<span class="token punctuation">.</span>rchild<span class="token punctuation">.</span>val
        <span class="token keyword">return</span> node

    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        d <span class="token operator">=</span> val <span class="token operator">-</span> self<span class="token punctuation">.</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> val
        q <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">]</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            node <span class="token operator">=</span> q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> i <span class="token operator">&gt;=</span> node<span class="token punctuation">.</span>l <span class="token keyword">and</span> i <span class="token operator">&lt;=</span> node<span class="token punctuation">.</span>r<span class="token punctuation">:</span> node<span class="token punctuation">.</span>val <span class="token operator">+=</span> d
            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>
            <span class="token keyword">for</span> child <span class="token keyword">in</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>lchild<span class="token punctuation">,</span> node<span class="token punctuation">.</span>rchild<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> child<span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>child<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">sumRange</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> j<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        ret <span class="token operator">=</span> <span class="token number">0</span>
        q <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">]</span>
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            node <span class="token operator">=</span> q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">continue</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>l <span class="token operator">&gt;=</span> i <span class="token keyword">and</span> node<span class="token punctuation">.</span>r <span class="token operator">&lt;=</span> j<span class="token punctuation">:</span>
                ret <span class="token operator">+=</span> node<span class="token punctuation">.</span>val
            <span class="token keyword">elif</span> node<span class="token punctuation">.</span>l <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>
                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>lchild<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> node<span class="token punctuation">.</span>r <span class="token operator">&gt;</span> i<span class="token punctuation">:</span>
                q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>rchild<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ret
</code></pre></div><p>[未完待续]</p></div></div> <!----></div> <div class="footer" data-v-3ef679b5><div class="footer-content page" data-v-3ef679b5><div class="left" data-v-3ef679b5><div class="footer-title" data-v-3ef679b5>FRIEND LINKS</div> <div class="links footer-text" data-v-3ef679b5></div> <div class="footer-text" data-v-3ef679b5><span id="busuanzi_container_site_pv" class="footer-count" data-v-3ef679b5><span id="busuanzi_value_site_pv" data-v-3ef679b5></span> <span id="busuanzi_value_site_uv" data-v-3ef679b5></span></span> <div class="counter" data-v-3ef679b5><div class="counter-title" data-v-3ef679b5>PAGE VIEWS</div> <div class="counter-content" data-v-3ef679b5><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span></div></div> <div class="counter" data-v-3ef679b5><div class="counter-title" data-v-3ef679b5>USER VIEWS</div> <div class="counter-content" data-v-3ef679b5><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span></div></div></div> </div> <div class="right" data-v-3ef679b5><div class="footer-title power" data-v-3ef679b5>POWERED BY</div> <a href="https://github.com/Yidadaa/Issue-Blog-With-Github-Action" class="logo" data-v-3ef679b5>ISSUE BLOG</a></div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ac476203.js" defer></script><script src="/assets/js/11.cfdfc7a9.js" defer></script><script src="/assets/js/6.e85e9b95.js" defer></script><script src="/assets/js/2.2db01773.js" defer></script><script src="/assets/js/33.19947ba8.js" defer></script><script src="/assets/js/5.63cd31eb.js" defer></script>
  </body>
</html>
