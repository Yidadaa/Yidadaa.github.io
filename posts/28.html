<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>树和数组的千层套路 | YiFei Zhang&#39;s Blog</title>
    <meta name="description" content="在这里了解我的一切，对编程的热爱永不停歇。">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="stylesheet" href="https://cdn.bootcss.com/prism/9000.0.1/themes/prism.min.css">
  <link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.5.1/katex.min.css">
  <script charset="utf-8" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="true"></script>
  <link rel="icon" type="image/png" href="https://avatars2.githubusercontent.com/u/16968934?s=460&amp;v=4">
    
    <link rel="preload" href="/assets/css/0.styles.a829d6f9.css" as="style"><link rel="preload" href="/assets/js/app.fa2690b4.js" as="script"><link rel="preload" href="/assets/js/11.da515c57.js" as="script"><link rel="preload" href="/assets/js/7.39f10487.js" as="script"><link rel="preload" href="/assets/js/2.45587f1b.js" as="script"><link rel="preload" href="/assets/js/33.a3c1f73c.js" as="script"><link rel="preload" href="/assets/js/5.be1c831e.js" as="script"><link rel="prefetch" href="/assets/js/10.b8fe8ff8.js"><link rel="prefetch" href="/assets/js/12.a88d47ad.js"><link rel="prefetch" href="/assets/js/13.03098b57.js"><link rel="prefetch" href="/assets/js/14.a4ff20e2.js"><link rel="prefetch" href="/assets/js/15.4571e977.js"><link rel="prefetch" href="/assets/js/16.d6c8f141.js"><link rel="prefetch" href="/assets/js/17.6ade90d4.js"><link rel="prefetch" href="/assets/js/18.51227d1e.js"><link rel="prefetch" href="/assets/js/19.48bf044b.js"><link rel="prefetch" href="/assets/js/20.aec6335d.js"><link rel="prefetch" href="/assets/js/21.11aed02a.js"><link rel="prefetch" href="/assets/js/22.081caef2.js"><link rel="prefetch" href="/assets/js/23.d552aa51.js"><link rel="prefetch" href="/assets/js/24.6e0bc225.js"><link rel="prefetch" href="/assets/js/25.5c2adf27.js"><link rel="prefetch" href="/assets/js/26.7f0d6a28.js"><link rel="prefetch" href="/assets/js/27.83b219b9.js"><link rel="prefetch" href="/assets/js/28.e0805bb0.js"><link rel="prefetch" href="/assets/js/29.7c58b78f.js"><link rel="prefetch" href="/assets/js/3.22157900.js"><link rel="prefetch" href="/assets/js/30.3af72d2d.js"><link rel="prefetch" href="/assets/js/31.c1d3f7de.js"><link rel="prefetch" href="/assets/js/32.fd910e5f.js"><link rel="prefetch" href="/assets/js/34.d5566f8e.js"><link rel="prefetch" href="/assets/js/35.6c33dda9.js"><link rel="prefetch" href="/assets/js/36.c036b4c8.js"><link rel="prefetch" href="/assets/js/37.d3e18657.js"><link rel="prefetch" href="/assets/js/38.d2f960c9.js"><link rel="prefetch" href="/assets/js/39.412b66b6.js"><link rel="prefetch" href="/assets/js/4.cfc121ba.js"><link rel="prefetch" href="/assets/js/40.fc7e81c5.js"><link rel="prefetch" href="/assets/js/6.96566b85.js"><link rel="prefetch" href="/assets/js/8.82c6f851.js"><link rel="prefetch" href="/assets/js/9.b853caf2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a829d6f9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="header-wrap" data-v-33920667><div class="header page" data-v-33920667><div class="left" data-v-33920667><div class="motto" data-v-33920667></div> <div class="nav" data-v-33920667></div></div> <div class="right" data-v-33920667><div class="search-box" data-v-33920667><input aria-label="Search" placeholder="" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></div> <div class="page post-page"><div class="title"><div class="post-title">树和数组的千层套路</div></div> <div class="info"><div class="author">Yidadaa</div> <div class="date">2020/03/18</div> <div class="count"><span id="busuanzi_value_page_pv"></span> <span>views</span></div></div> <div class="post-content"><div class="content__default"><h1 id="树和数组的千层套路"><a href="#树和数组的千层套路" class="header-anchor">#</a> 树和数组的千层套路</h1> <blockquote><p>今天教你怎么在线性数组和二叉树间反复横跳。</p></blockquote> <p>目录：</p> <ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_0" checked="checked" disabled="disabled"><label for="cbx_0"> 二叉堆</label></li> <li class="task-list-item"><input type="checkbox" id="cbx_1" disabled="disabled"><label for="cbx_1"> 树状数组</label></li> <li class="task-list-item"><input type="checkbox" id="cbx_2" disabled="disabled"><label for="cbx_2"> 线段树</label></li></ul> <p>在最简单的一类数据结构中，有两种最为基础：线性数组和树，它们在实际的应用中十分常用，比如线性数组用来存储结构化数据，树用来存储一些有层级归属关系的数据。一个最典型的使用树的场景就是浏览器中的 GUI 渲染策略，在你阅读本篇文章的时候，浏览器就已经从 HTML 文件中解析出当前界面上的所有元素，并按照从属关系依次渲染出来，你只需要按下键盘上的 <code>F12</code> 键，就可以看到页面中所有元素的从属关系。</p> <p>然而，一般意义上的树并不是高度结构化的数据，虽然一颗树的所有信息都可以由根节点遍历出来，但是在没有提前建立索引的情况下，你很难轻易地直接获取树中任意节点的数据。所以人们为了更高的随机索引速度，会更倾向于使用结构稳定的二叉树，尤其是完全二叉树，这是由于完全二叉树的左右子树高度差不超过 1，其每层的节点数量都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> ，所以完全二叉树可以很轻松地存储在线性数组里，然后通过 <code>child = tree[parent_index * 2]</code> 的方式去递推任意孩子节点的索引值。</p> <p>二叉树的这种特性使得树状结构可以很方便地存储在线性数组中，而本文就将阐述那些和线性数组关系紧密的树状数据结构们。</p> <h2 id="二叉堆"><a href="#二叉堆" class="header-anchor">#</a> 二叉堆</h2> <p>在使用二叉堆之前，你需要知道什么是堆，以及为什么要有堆。</p> <p>根据<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D" target="_blank" rel="noopener noreferrer">维基百科<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的描述，堆是一种具有特殊顺序的树，也就是说，堆就是一种树，就像二叉搜索树那样，堆的节点间也有一些大小关系，最常用的堆是<strong>最大堆</strong>和<strong>最小堆</strong>，又称大（小）顶堆、大（小）根堆等，以最大堆为例，最大堆中的任意一个节点都比它的子节点的值更大，也就是说，堆的根节点的元素是整个堆的最大值，值得注意的是，这种大小约束只对父节点和子节点生效，而相同层级的节点不需要有大小关系上的约束。</p> <p><img src="https://user-images.githubusercontent.com/16968934/77818922-a1bb2280-7111-11ea-8eef-a4c8ab7e5783.png" alt="image"></p> <p>除此之外，堆还必须是一颗完全二叉树，这可以保证对堆的各种操作的均摊复杂度最低。</p> <p>但是你可能会依然很疑惑，就像我在数据结构课上听到一个全新的数据结构的时候，心里会想：“wow, awesome, 然后呢？”，人们造出来拥有很多复杂结构的事物，并不是完全为了消磨时间，而是因为为了解决问题而不得不让这些工具变得这么复杂，本文中提到的三种数据结构也是如此，它们本身的特性使得它们在解决某些问题时异常好用。</p> <p>而堆的最常用例子就是优先队列，你可以看到堆的根节点始终是最大值或者最小值，这种最值可以以优先级的形式体现出来，而且这种极值顺序会在动态增减的过程中始终以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间复杂度保持着，回想一下，如果你要对一个普通的线性数组取极大值，你就不得不付出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的时间复杂度。堆的特性可以大大降低很多需要动态维护优先级的算法的复杂度，比如原始的<a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="noopener noreferrer">迪杰斯特拉最短路径算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，而使用堆优化后可以达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N logN)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p> <p>现在你知道了什么是堆，以及堆用来解决那些问题，下面就介绍一下堆的常用操作，本文所述的堆均代表二叉堆。</p> <p>二叉堆通常存储在一个数组中，而堆的插入（insert）、弹出（pop）、取堆顶（top）、删除（remove）操作均可以通过不断交换数组元素来完成，而这些操作均有两个最基础的操作组成：向上调整（up）和向下调整（down），顾名思义，向上调整就是从当前节点开始向根节点遍历，确认该路径上所有节点是否满足“子节点小于（大于）父节点”的顺序，如果不满足，则进行调整；而向下调整则是向叶子节点进行遍历，然后执行同样的操作，写成代码形式（以最大堆为例）：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>heap <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  <span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

  <span class="token keyword">def</span> <span class="token function">up</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''向上调整第 k 个节点'''</span>
    <span class="token keyword">while</span> k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        parent_index <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        <span class="token comment"># 如果子节点大于父节点，则进行调整</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>parent_index<span class="token punctuation">]</span><span class="token punctuation">:</span>
          self<span class="token punctuation">.</span>swap<span class="token punctuation">(</span>k<span class="token punctuation">,</span> parent_index<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">break</span>

  <span class="token keyword">def</span> <span class="token function">down</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
    <span class="token triple-quoted-string string">'''向下调整第 k 个节点'''</span>
    <span class="token keyword">while</span> k <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span><span class="token punctuation">:</span>
      lchild<span class="token punctuation">,</span> rchild <span class="token operator">=</span> k <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>
      <span class="token comment"># 两个子节点取较大节点</span>
      child <span class="token operator">=</span> lchild <span class="token keyword">if</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>lchild<span class="token punctuation">]</span> <span class="token operator">&gt;</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>rchild<span class="token punctuation">]</span> <span class="token keyword">or</span> rchild <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token keyword">else</span> rchild
      <span class="token keyword">if</span> child <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&gt;</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>swap<span class="token punctuation">(</span>child<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
        k <span class="token operator">=</span> child
      <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">break</span>
</code></pre></div><p>可以看到，调整部分的代码的逻辑还是比较清晰的，只需要不断向上或者向下遍历，然后调整对应的值即可。有了两个基础操作，我们可以很方便地完成插入、弹出、取顶、删除等操作了，直接看代码：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">'''省略 up, down 部分的代码'''</span>
  <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''将 val 插入堆中'''</span>
    self<span class="token punctuation">.</span>heap<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment"># 插到数组尾部</span>
    self<span class="token punctuation">.</span>up<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 然后不断向上调整即可</span>

  <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''获取堆顶值'''</span>
    <span class="token keyword">return</span> <span class="token boolean">None</span> <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># 只需返回数组中的第一个元素即可</span>

  <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''移除第 k 个节点'''</span>
    self<span class="token punctuation">.</span>swap<span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>heap<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 将第 k 个元素交换到尾部</span>
    ret <span class="token operator">=</span> self<span class="token punctuation">.</span>heap<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 将其从数组中删除</span>
    self<span class="token punctuation">.</span>up<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token comment"># 确认是否需要向上调整</span>
    self<span class="token punctuation">.</span>down<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token comment"># 确认是否需要向下调整</span>
    <span class="token keyword">return</span> ret

  <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''弹出堆顶'''</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><p>掌握了二叉堆，我们可以很轻松地解决 TOP-k 问题，以及所有需要使用到优先队列的问题，不过值得一提的是，二叉堆作为一种非常常用的数据结构，已经被内置到很多语言的官方库中，在实际使用或者写算法题时，建议直接调包使用，比如 Python3 的 <code>queue.PriorityQueue</code> 和 <code>heapq</code>，以及 C++ 的 <code>priority_queue</code> 等。</p> <h2 id="树状数组"><a href="#树状数组" class="header-anchor">#</a> 树状数组</h2> <p>[TODO]</p> <h2 id="线段树"><a href="#线段树" class="header-anchor">#</a> 线段树</h2> <p>[TODO]</p></div></div> <!----></div> <div class="footer" data-v-084e37ac><div class="footer-content page" data-v-084e37ac><div class="left" data-v-084e37ac><div class="footer-title" data-v-084e37ac>Friend Links</div> <div class="links footer-text" data-v-084e37ac></div> <div class="footer-title" data-v-084e37ac>Visitor Report</div> <div class="footer-text" data-v-084e37ac><span id="busuanzi_container_site_pv" class="footer-count" data-v-084e37ac><div data-v-084e37ac><span class="count-title" data-v-084e37ac>Total PV</span> <span id="busuanzi_value_site_pv" data-v-084e37ac></span></div> <div data-v-084e37ac><span class="count-title" data-v-084e37ac>Total UV</span> <span id="busuanzi_value_site_uv" data-v-084e37ac></span></div></span></div> </div> <div class="right" data-v-084e37ac><div class="footer-title power" data-v-084e37ac>Powered by</div> <a href="https://github.com/Yidadaa/Issue-Blog-With-Github-Action" class="logo" data-v-084e37ac>ISSUE BLOG</a></div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.fa2690b4.js" defer></script><script src="/assets/js/11.da515c57.js" defer></script><script src="/assets/js/7.39f10487.js" defer></script><script src="/assets/js/2.45587f1b.js" defer></script><script src="/assets/js/33.a3c1f73c.js" defer></script><script src="/assets/js/5.be1c831e.js" defer></script>
  </body>
</html>
